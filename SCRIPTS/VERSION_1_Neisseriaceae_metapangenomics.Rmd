---
title: "Neisseriaceae metapangenomics in human oral cavity"
author: "J. J. Giacomini"
date: "2023-08"
output: html_document
---

# log in

```{bash, eval=FALSE}

ssh jgiacomini@evol5.mbl.edu 
ssh Barhal

ssh -L 8080:localhost:8080 jgiacomini@evol5.mbl.edu 
ssh -L 8080:localhost:8080 Barhal



```

# 1. Metaphlan 4 analysis 

```{r Family relative abundance}

library(ggplot2)
library(ggh4x)
library(reshape2)
library(tidyr)
library(vegan)
library(ggdendro)
library(RColorBrewer)
library(scales)



metaphlan_family_df <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/DATA/Metaphlan4_vJan21_Nesseriaceae_family_abundance.txt", header = TRUE)


# melt wide to long
metaphlan_family_df_melted <- reshape2::melt(metaphlan_family_df)

# make oral site variable for facet grid
metaphlan_family_df_melted <- metaphlan_family_df_melted %>% 
  mutate(site = case_when(grepl('_TD', variable) ~ 'TD',
                          grepl('_KG', variable) ~ 'KG', 
                          grepl('_SUPP', variable) ~ 'SUPP',
                          grepl('_SUBP', variable) ~ 'SUBP',
                          grepl('_SV', variable) ~ 'SV',
                          grepl('_TH', variable) ~ 'TH',
                          grepl('_PT', variable) ~ 'PT',
                          grepl('_HP', variable) ~ 'HP',
                          grepl('_BM', variable) ~ 'BM',
                          grepl('_PERIO', variable) ~ 'PERIO'))

# subset data frame for clustering species
metaphlan_clustering_df <- metaphlan_family_df_melted %>% 
  select(clade_name, variable, value)

# pivot wider
wide_df <- metaphlan_clustering_df %>% tidyr::pivot_wider(names_from = variable, values_from = value)

# make tibble into data frame object
wide_df <- as.data.frame(wide_df)

# rename row names to species IDs
wide_df2 <- wide_df[,-1]
rownames(wide_df2) <- wide_df[,1]

# convert to matrix
wide_matrix <- as.matrix(wide_df2)

# calculate Bray-Curtis distance among samples
dist_df <- vegan::vegdist(wide_matrix, method = "bray")


#Replace na values with 0 using is.na()
dist_df[dist_df=="NaN"]<-0

# Hierarchical clustering using Complete Linkage
hc <- hclust(dist_df, method = "complete" )

# create dedrogram object
dhc <- as.dendrogram(hc)

# create rectangular lines object
ddata <- ggdendro::dendro_data(dhc, type = "rectangle")

species_dend_plot <- ggplot(segment(ddata)) + 
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend), linewidth = 1) + 
  coord_flip() + 
  scale_y_reverse(expand = c(0.2, 0)) +
  scale_x_reverse() +
  theme_classic() +
  theme(axis.ticks.y = element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.x = element_blank(),
        axis.text.y =  element_blank(),
        axis.line.x = element_blank(),
        axis.line.y = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_blank()) +
  theme(panel.spacing.x=unit(0.05, "lines"),
        plot.margin=unit(c(0,0,0,0), "cm"))

# save dend plot
ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/FIGURES/Relative_Abundance/Family_dendrogram_all_sites.pdf",species_dend_plot, width = 5, height = 7)

# reorder species based on hclust
family_order <- hc$labels[hc$order]

metaphlan_family_df_melted$clade_name <- factor(metaphlan_family_df_melted$clade_name, levels = family_order)


####### Sample order; need to cluster each site seperately, then get order, and then concatenate the orders #####

# created vector with 5 characters
columns= c("order")

# pass this vector length to ncol parameter
# and nrow with 0
site_order_df = data.frame(matrix(nrow = 0, ncol = length(columns)))

# assign column names
colnames(site_order_df) = columns


site_list <- list("SUPP", "SUBP", "KG", "BM", "TD", "PT", "TH", "SV", "PERIO") 


for (oral_site in site_list) {
  
  # filter df by site
  site_df <- metaphlan_family_df_melted %>% 
    filter(site == oral_site)
  
  # subset data frame for clustering species
  site_clustering_df <- site_df %>% 
    select(clade_name, variable, value)
  
  # pivot wider
  site_wide_df <- site_clustering_df %>% pivot_wider(names_from = variable, values_from = value)
  
  # make tibble into data frame object
  site_wide_df <- as.data.frame(site_wide_df)
  
  # rename row names to species IDs
  site_wide_df2 <- site_wide_df[,-1]
  rownames(site_wide_df2) <- site_wide_df[,1]
  
  # convert to matrix
  site_wide_matrix <- as.matrix(site_wide_df2)
  
  # transpose data frame so that we can cluster samples based on euclidan distance and complete linkage
  trans_site_wide_matrix <- t(site_wide_matrix)
  
  # calculate Bray-Curtis distance among samples
  site_dist_df <- vegan::vegdist(trans_site_wide_matrix, method = "bray")
  
  #Replace na values with 0 using is.na()
  site_dist_df[site_dist_df=="NaN"]<-0
  
  # Hierarchical clustering using Complete Linkage
  site_hc <- hclust(site_dist_df, method = "complete" )
  
  # create dedrogram object
  site_dhc <- as.dendrogram(site_hc)
  
  # create rectangular lines object
  site_ddata <- dendro_data(site_dhc, type = "rectangle")
  
  site_samples_dend_plot <- ggplot(segment(site_ddata)) + 
    geom_segment(aes(x = x, y = y, xend = xend, yend = yend), linewidth = 1) + 
    coord_flip() + 
    scale_y_reverse(expand = c(0.2, 0)) +
    scale_x_reverse() +
    theme_classic() +
    theme(axis.ticks.y = element_blank(),
          axis.ticks.x=element_blank(),
          axis.text.x = element_blank(),
          axis.text.y =  element_blank(),
          axis.line.x = element_blank(),
          axis.line.y = element_blank(),
          axis.title.y = element_blank(),
          axis.title.x = element_blank()) +
    theme(panel.spacing.x=unit(0.05, "lines"),
          plot.margin=unit(c(0,0,0,0), "cm"))
  
  # save dend plot
  ggsave(paste0("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/FIGURES/Relative_Abundance/",oral_site,"_samples_dendrogram_all_sites_FAMILY_plots.pdf"),site_samples_dend_plot, width = 5, height = 7)
  
  
  # get list of sample order for site
  
  site_order <- data.frame(order = site_hc$labels[site_hc$order])
  
  site_order_df <- rbind(site_order_df, site_order)
  
}


# add HP sample to the end of the order 
metaphlan_family_df_melted$variable[metaphlan_family_df_melted$site == "HP"] #"SRS062878_HP.profile"
site_order_df <- rbind(site_order_df, "SRS062878_HP.profile")

# reorder samples based on concatenated hclust order
samples_order <- metaphlan_family_df_melted$variable <- factor(metaphlan_family_df_melted$variable, levels = site_order_df$order)


# set order of oral sites based on similar physical properties
metaphlan_family_df_melted$site <- factor(metaphlan_family_df_melted$site, levels = c("SUPP", "SUBP", "KG", "BM", "TD", "PT", "HP", "TH", "SV", "PERIO"))


# Create a filtered dataframe
filtered_df <- metaphlan_family_df_melted %>%
  group_by(clade_name) %>%
  summarise(mean_value = mean(value)) %>%
  filter(mean_value >= 1.0) %>%
  droplevels() %>% 
  select(clade_name)

filtered_df_joined <- metaphlan_family_df_melted %>% 
  filter(clade_name %in% filtered_df$clade_name) %>% 
  droplevels()

# Check the result
str(filtered_df_joined)

```


Plot of family level relative abundance estimated using MetaPhlan4 (vJan21) - families with less than 1% relative abundance averaged across all sites excluded. 
```{r Family plot }
# set colors for heat map
paleta_new = rev(RColorBrewer::brewer.pal(n = 11, name = "RdYlBu"))

# plot 
Neisseriaceae_metaphlan4_plot_2 <- ggplot(data = filtered_df_joined, aes(x=variable, y=clade_name, fill=value)) + 
  geom_tile(height=1, width=1) + 
  facet_grid(. ~ site, scales = "free", space = "free", switch = "x") + 
  scale_fill_gradientn(colours = paleta_new, limits=c(0, 10), breaks=seq(0,10,by=2),oob=squish) + 
  scale_y_discrete(limits = levels(filtered_df_joined$clade_name)) +
  ylab(NULL) +  
  xlab(NULL) + 
  guides(fill = guide_colourbar(barwidth = 1,
                                barheight = 10,
                                title = "%",
                                ticks = TRUE,
                                ticks.colour = "white",
                                ticks.linewidth = 0.5)) +
  theme_classic() + 
  theme(text = element_text(size = 10, color = "black"),
        axis.ticks.y = element_line(linewidth = 1),
        axis.text.x=element_blank(),
        axis.text.y =  element_text(face = "italic", color = "black"),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        panel.background = element_blank(),
        strip.background = element_rect(colour=NA, fill=NA)) + 
  force_panelsizes(cols = unit(c(4,1,1,4,4,1,0.5,1,1,1), "cm"), 
                 TRUE)

Neisseriaceae_metaphlan4_plot_2

ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/FIGURES/Relative_Abundance/metaphlan4_FAMILY_relative_abundance_greater_than_1percent.pdf", Neisseriaceae_metaphlan4_plot_2, width = 11, height = 6)

```


```{r Build relative abundance heat map}

library(ggplot2)
library(ggh4x)
library(reshape2)
library(tidyr)
library(vegan)
library(ggdendro)
library(RColorBrewer)
library(scales)



metaphlan_df <- read.csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/DATA/Metaphlan4_jan31db_Neisseriaceae.csv", header = TRUE)

# melt wide to long
metaphlan_df_melted <- reshape2::melt(metaphlan_df)

# make oral site variable for facet grid
metaphlan_df_melted <- metaphlan_df_melted %>% 
  mutate(site = case_when(grepl('_TD', variable) ~ 'TD',
                          grepl('_KG', variable) ~ 'KG', 
                          grepl('_SUPP', variable) ~ 'SUPP',
                          grepl('_SUBP', variable) ~ 'SUBP',
                          grepl('_SV', variable) ~ 'SV',
                          grepl('_TH', variable) ~ 'TH',
                          grepl('_PT', variable) ~ 'PT',
                          grepl('_HP', variable) ~ 'HP',
                          grepl('_BM', variable) ~ 'BM',
                          grepl('_PERIO', variable) ~ 'PERIO'))


# subset data frame for clustering species
metaphlan_clustering_df <- metaphlan_df_melted %>% 
  select(clade_name, variable, value)

# pivot wider
wide_df <- metaphlan_clustering_df %>% tidyr::pivot_wider(names_from = variable, values_from = value)

# make tibble into data frame object
wide_df <- as.data.frame(wide_df)

# rename row names to species IDs
wide_df2 <- wide_df[,-1]
rownames(wide_df2) <- wide_df[,1]

# convert to matrix
wide_matrix <- as.matrix(wide_df2)

# calculate Bray-Curtis distance among samples
dist_df <- vegan::vegdist(wide_matrix, method = "bray")


#Replace na values with 0 using is.na()
dist_df[dist_df=="NaN"]<-0

# Hierarchical clustering using Complete Linkage
hc <- hclust(dist_df, method = "complete" )

# create dedrogram object
dhc <- as.dendrogram(hc)

# create rectangular lines object
ddata <- ggdendro::dendro_data(dhc, type = "rectangle")

species_dend_plot <- ggplot(segment(ddata)) + 
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend), linewidth = 1) + 
  coord_flip() + 
  scale_y_reverse(expand = c(0.2, 0)) +
  scale_x_reverse() +
  theme_classic() +
  theme(axis.ticks.y = element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.x = element_blank(),
        axis.text.y =  element_blank(),
        axis.line.x = element_blank(),
        axis.line.y = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_blank()) +
  theme(panel.spacing.x=unit(0.05, "lines"),
        plot.margin=unit(c(0,0,0,0), "cm"))

# save dend plot
ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/FIGURES/Relative_Abundance/species_dendrogram_all_sites.pdf",species_dend_plot, width = 5, height = 7)



# reorder species based on hclust
species_order <- hc$labels[hc$order]

metaphlan_df_melted$clade_name <- factor(metaphlan_df_melted$clade_name, levels = species_order)



####### Sample order; need to cluster each site seperately, then get order, and then concatenate the orders #####

# created vector with 5 characters
columns= c("order")

# pass this vector length to ncol parameter
# and nrow with 0
site_order_df = data.frame(matrix(nrow = 0, ncol = length(columns)))

# assign column names
colnames(site_order_df) = columns


site_list <- list("SUPP", "SUBP", "KG", "BM", "TD", "PT", "TH", "SV", "PERIO") 


for (oral_site in site_list) {
  
  # filter df by site
  site_df <- metaphlan_df_melted %>% 
    filter(site == oral_site)
  
  # subset data frame for clustering species
  site_clustering_df <- site_df %>% 
    select(clade_name, variable, value)
  
  # pivot wider
  site_wide_df <- site_clustering_df %>% pivot_wider(names_from = variable, values_from = value)
  
  # make tibble into data frame object
  site_wide_df <- as.data.frame(site_wide_df)
  
  # rename row names to species IDs
  site_wide_df2 <- site_wide_df[,-1]
  rownames(site_wide_df2) <- site_wide_df[,1]
  
  # convert to matrix
  site_wide_matrix <- as.matrix(site_wide_df2)
  
  # transpose data frame so that we can cluster samples based on euclidan distance and complete linkage
  trans_site_wide_matrix <- t(site_wide_matrix)
  
  # calculate Bray-Curtis distance among samples
  site_dist_df <- vegan::vegdist(trans_site_wide_matrix, method = "bray")
  
  #Replace na values with 0 using is.na()
  site_dist_df[site_dist_df=="NaN"]<-0
  
  # Hierarchical clustering using Complete Linkage
  site_hc <- hclust(site_dist_df, method = "complete" )
  
  # create dedrogram object
  site_dhc <- as.dendrogram(site_hc)
  
  # create rectangular lines object
  site_ddata <- dendro_data(site_dhc, type = "rectangle")
  
  site_samples_dend_plot <- ggplot(segment(site_ddata)) + 
    geom_segment(aes(x = x, y = y, xend = xend, yend = yend), linewidth = 1) + 
    coord_flip() + 
    scale_y_reverse(expand = c(0.2, 0)) +
    scale_x_reverse() +
    theme_classic() +
    theme(axis.ticks.y = element_blank(),
          axis.ticks.x=element_blank(),
          axis.text.x = element_blank(),
          axis.text.y =  element_blank(),
          axis.line.x = element_blank(),
          axis.line.y = element_blank(),
          axis.title.y = element_blank(),
          axis.title.x = element_blank()) +
    theme(panel.spacing.x=unit(0.05, "lines"),
          plot.margin=unit(c(0,0,0,0), "cm"))
  
  # save dend plot
  ggsave(paste0("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/FIGURES/Relative_Abundance/",oral_site,"_samples_dendrogram_all_sites.pdf"),site_samples_dend_plot, width = 5, height = 7)
  
  
  # get list of sample order for site
  
  site_order <- data.frame(order = site_hc$labels[site_hc$order])
  
  site_order_df <- rbind(site_order_df, site_order)
  
}


# add HP sample to the end of the order 
metaphlan_df_melted$variable[metaphlan_df_melted$site == "HP"] #"SRS062878_HP.profile"
site_order_df <- rbind(site_order_df, "SRS062878_HP.profile")

# reorder samples based on concatenated hclust order
samples_order <- metaphlan_df_melted$variable <- factor(metaphlan_df_melted$variable, levels = site_order_df$order)


# set order of oral sites based on similar physical properties
metaphlan_df_melted$site <- factor(metaphlan_df_melted$site, levels = c("SUPP", "SUBP", "KG", "BM", "TD", "PT", "HP", "TH", "SV", "PERIO"))


# set colors for heat map
paleta_new = rev(RColorBrewer::brewer.pal(n = 11, name = "RdYlBu"))

# plot 1
Neisseriaceae_metaphlan4_plot <- ggplot(data = metaphlan_df_melted, aes(x=variable, y=clade_name, fill=value)) + 
  geom_tile(height=1, width=1) + 
  facet_grid(. ~ site, scales = "free", space = "free", switch = "x") + 
  scale_fill_gradientn(colours = paleta_new, limits=c(0, 5), breaks=seq(0,5,by=1),oob=squish) + 
  scale_y_discrete(limits = levels(metaphlan_df_melted$clade_name)) +
  ylab(NULL) +  
  xlab(NULL) + 
  guides(fill = guide_colourbar(barwidth = 1,
                                barheight = 10,
                                title = "%",
                                ticks = TRUE,
                                ticks.colour = "white",
                                ticks.linewidth = 0.5)) +
  theme_classic() + 
  theme(text = element_text(size = 10, color = "black"),
        axis.ticks.y = element_line(linewidth = 1),
        axis.text.x=element_blank(),
        axis.text.y =  element_text(face = "italic", color = "black"),
        axis.line.x = element_blank(),
        axis.ticks.x = element_blank(),
        panel.background = element_blank(),
        strip.background = element_rect(colour=NA, fill=NA)) + 
  force_panelsizes(cols = unit(c(4,1,1,4,4,1,0.5,1,1,1), "cm"), 
                 TRUE)

Neisseriaceae_metaphlan4_plot

ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/FIGURES/Relative_Abundance/metaphlan4_relative_abundance.pdf", Neisseriaceae_metaphlan4_plot, width = 11, height = 6)


# how many samples per site
metaphlan_df_melted %>% 
  group_by(site) %>% 
  summarise(n = n()/23)

# # A tibble: 10 × 2
# site      n
# <fct> <dbl>
#   1 SUPP    394
# 2 SUBP     24
# 3 KG       15
# 4 BM      323
# 5 TD      421
# 6 PT       22
# 7 HP        1
# 8 TH        7
# 9 SV        8
# 10 PERIO    24

```

# 2. Genome selection 

##### 2.1 Distribution of Neisseriacea genomes from NCBI


Please see the new NCBI datasets method which is foiund in the NCBI_command_line_datasets_tool.Rmd file



##### 2.3 Set up directories on MBL server

```{bash, eval=FALSE setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

ssh -L 8080:localhost:8080 jgiacomini@evol5.mbl.edu 
ssh -L 8080:localhost:8080 barhal-01

ssh jgiacomini@evol5.mbl.edu 
ssh Barhal

screen -S Neiss

```

module purge
module load miniconda/3
source /bioware/miniconda3/bashrc
conda activate anvio-7.1
module load clusters/barhal
module load jbpc



module load anvio
module load clusters/barhal
module load jbpc



```{bash, eval=FALSE variables for the environment}

# define variables unique to this project 
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
meta=$mainDIR/$projectID/DATA/Neisseriaceae_Final_metadata.csv
ITEMS=${projectID}-add_info.items.txt
seqidHOMD=/workspace/jmarkwelchlab/HOMD_INFO/SEQID_info.txt
DIR_SITE=/storage/data/00_Public_Metagenomes/oral/HMP/
hmpID=/workspace/jmarkwelchlab/HMP_METAGENOMES/METADATA/samples_id-QC.txt
hmpMetadata=/workspace/jmarkwelchlab/HMP_METAGENOMES/METADATA/sequencing-metadata-count-QC.tsv
minContigSIZE=300
TH=15

# directories (variables)
DIR_Data=DATA
DIR_Reads=00_READS
DIR_NCBI=01_NCBI_GENOMES
DIR_MEREN=01_MEREN_GENOMES
DIR_Assemblies=02_ASSEMBLIES
DIR_Contigs=03_GENOMES_EDITED
DIR_ContigsDB=04_CONTIGS_DB
DIR_Mapping=05_MAPPING
DIR_SinglePROF=06_SINGLE_PROFILE
DIR_MergedPROF=07_MERGED_PROFILE
DIR_SummaryPROF=08_PROFILE_SUMMARY
DIR_Pangenome=09_PANGENOME
DIR_SummaryPAN=10_PANGENOME_SUMMARY
DIR_Gene_calls=11_GENE_CALLS
DIR_Annotation=12_FUNCTIONAL_ANNOTATION
DIR_DetectionGENOMES=13_DETECTED_GENOMES
DIR_Phylo=14_PHYLOGENOMICS
DIR_Derep=15_DE_REPLICATION
DIR_var=22_GENE_LEVEL
DIR_CheckM=26_CHECKM

ITEMS
# files (variables)
genomeMetadata=$meta
projectMetadata=$DIR_Data/02_${projectID}.csv
downloadNCBI=$DIR_Data/03_${projectID}-download_url.txt
rawNCBIid=$DIR_Data/04_${projectID}-ncbi_raw_genomes_id.txt
genusList=$DIR_Data/05_${projectID}-genus_list.txt
checkNCBIid=$DIR_Data/06_${projectID}-check_genomes_id.txt
newHOMDid=$DIR_Data/07_${projectID}-homd_id.txt
genomesNCBIid=$DIR_Data/08_${projectID}-ncbi_genomes_id.txt
duplicateStrainNames=$DIR_Data/09_${projectID}-duplicate_strain_names.txt
duplicateStrainInfo=$DIR_Data/10_${projectID}-duplicate_strain_names_info.txt
removeDuplicate=$DIR_Data/11_${projectID}-duplicate_strain_removed.txt
magsID=$DIR_Data/12_mags_id-meren.txt
nameConversions=$DIR_Data/13_${projectID}-name_conversions.txt
genomesID=$DIR_Data/id_genomes.txt
genomesALL=$DIR_Data/id_genomes-ALL.txt
genomesRefSeq=$DIR_Data/id_genomes-RefSeq.txt
RAW_ASSEMBLY=$DIR_Assemblies/${projectID}-RAW.fa
PROJECT_CONTIGS=$DIR_Contigs/${projectID}.fa
PROJECT_REPORT=$DIR_Contigs/${projectID}.report.tsv
BINNING=$DIR_Contigs/${projectID}.binning.tsv
DECOMPOSE=$DIR_Contigs/${projectID}.decompose.tsv
CONTIGS_DB=$DIR_ContigsDB/${projectID}-contigs.db
GENE_CALLS=$DIR_Gene_calls/${projectID}-gene_calls.fa
PAN_LAYERS=$DIR_Pangenome/${projectID}-add_info.layers.tsv
samplesMetadata=DATA/${projectID}-samples_metadata.txt
LAYER_ORDERS=DATA/${projectID}-layer_orders.txt

genomesALL=DATA/id_genomes-ALL.txt
nameConversions=$DIR_Data/13_${projectID}-name_conversions.txt
iDir=$DIR_Pangenome/internal_annotated_${projectID}
genomeDB=$iDir/${projectID}-GENOMES.db
panDB_detection=$iDir/${projectID}-RESULTS/${projectID}-PAN_detection.db
genomes_98ANI=DATA/id_genomes-98ANI.txt

PanProject=${projectID}-98ANI
PanDir=$DIR_Pangenome/$PanProject
GENOMES_98ANI_DEREP=$PanDir/${PanProject}.txt
GENOMES_98ANI_DEREP_DB=$PanDir/${PanProject}-GENOMES.db
PAN_DIR=$PanDir/${PanProject}-RESULTS
PAN_DB=$PanDir/${PanProject}-RESULTS/${PanProject}-PAN.db
ANI_DIR=$PanDir/${PanProject}-RESULTS/ANI_RESULTS
layersADD_98ANI=$PanDir/${PanProject}-layers_98ANI.tsv
PAN_DES=DATA/description_98ANI_derep_pangenome.txt

```

```{bash, eval=FALSE}
#
mkdir $mainDIR/$projectID && cd $mainDIR/$projectID

# create directories
mkdir $DIR_Data $DIR_Reads $DIR_NCBI $DIR_MEREN $DIR_Assemblies $DIR_Contigs $DIR_ContigsDB $DIR_Mapping $DIR_SinglePROF $DIR_MergedPROF $DIR_SummaryPROF $DIR_Pangenome $DIR_SummaryPAN $DIR_DetectionGENOMES $DIR_Gene_calls $DIR_Annotation $DIR_Phylo $DIR_Derep $DIR_CheckM

# copy samples id and metadata-count
#cp $hmpID samples_id-QC.txt
#cp $hmpMetadata sequencing-metadata-count-QC.tsv
```


##### 2.4 Download genomes

I created a metadata file with information about the 620 genomes that we need (excluding Men and Gon genomes that we are processing separately. The file is called RefSeq_non_men_or_gon.csv which is the second tab of the 10_13_2023_FINAL_merged_datasets_and_genbank_metadata.xlsx file. The RefSeq_non_men_or_gon.csv can be used to download the new genomes.

```{bash, eval=FALSE download new genomes}
# upload NCBI metadata file onto the server (Run on local machine)
scp -r /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/NCBI_DATASETS/RefSeq_non_men_or_gon.csv jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/DATA/RefSeq_non_men_or_gon_new_genomes.csv


scp -r /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/NCBI_DATASETS/ftp_paths_parents.txt jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/DATA/new_genomes_ftp_paths_parents.txt

genomeMetadata=/workspace/jmarkwelchlab/P_0003_Neisseriaceae/DATA/RefSeq_non_men_or_gon_new_genomes.csv

# copy NCBI metadata for desired genomes (RefSeq)
cat $genomeMetadata | awk 'BEGIN{FS=OFS=","}NR==1{print $0}NR>1{print $0}' > $projectMetadata

# make url file
cat DATA/new_genomes_ftp_paths_parents.txt | awk 'BEGIN{FS=OFS="/"}{print $0,$NF"_genomic.fna.gz"}' > $downloadNCBI

# Download genomes
clusterize -n 5 -l LOGS/New_genomes_10_13_2023_download_genomes.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/download_genomes.sh

```



##### 2.5 Rename genomes

Anvio doesn't like complicated genome IDs so we have to create a list of unique IDs containing a number and the assembly ID separated by "_id_"; use GCA assembly ID column 9

```{bash, eval=FALSE rename new genomes}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_NCBI=$mainDIR/$projectID/01_NCBI_GENOMES
DIR_Assemblies=$mainDIR/$projectID/02_ASSEMBLIES
DIR_Data=$mainDIR/$projectID/DATA
projectMetadata=$DIR_Data/02_${projectID}.csv
genomesNCBIid=$DIR_Data/new_08_P_0003_Neisseriaceae-ncbi_genomes_id.txt
rawNCBIid=$DIR_Data/new_04_P_0003_Neisseriaceae-ncbi_raw_genomes_id.txt
genomesID=$DIR_Data/new_id_genomes.txt

# create a list of unique IDs containing a number and the assembly ID separated by "_id_"; use GCA assembly ID column 7
# (e.g. G_0001_id_GCA_000000000.0)
cat $projectMetadata | awk -F',' -v OFS="\t" 'NR>1{ printf "G_""%04i_id_%s\n", NR-1,$1 }' | sed -e 's/"//g'  > $rawNCBIid

# copy
cp $rawNCBIid $genomesNCBIid
cp $rawNCBIid $genomesID

# create new fasta files for each genome and 
# change names of original fasta file to number a number using the $genomesID file
# (e.g. GCA_901873365.1_Aggregatibacter_sp._BgEED05_genomic.fna -> G_0001-RAW.fa)

while IFS= read -r genomes_id
do
gca_id=$(echo $genomes_id | awk -F'_id_' '{print $2}')
old_name=$(find $DIR_NCBI -name "$gca_id*")
NEW_NAME=$(echo "$genomes_id" | awk -F'_id_' -v new_dir="$DIR_Assemblies" '{print new_dir"/"$1"-RAW.fa"}' )
cp $old_name $NEW_NAME
done < $genomesID

# remove GCA number from $genomesID file to match new fasta file names
sed -i 's/_id_.*//' $genomesID

```

##### 2.6 Reformat genome deflines & build anvio contigs databases for each genome

Using ANVIO (anvi-script-reformat-fasta) to change any non-canonical letter with N this is done in batches of 20 in a background process

Anvi'o used Prodigal (v2.6.3) by Hyatt et al (doi:10.1186/1471-2105-11-119) to identify open reading frames in the data. 

```{bash, eval=FALSE new genomes}

clusterize -n 5 -l LOGS/New_620_genomes_reformat_genomes_and_anvio_contigDBs.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/reformat_genome_deflines_and_build_contig_databases.sh
```


Looks like one contigs DB failed... 
```{bash check contig databases} 

# check: the number should be 620, but is actually 619
cat LOGS/New_620_genomes_reformat_genomes_and_anvio_contigDBs.log | grep "✓ anvi-gen-contigs-database" | wc -l

# Make a file that shows if each genome has a successful contig db built
cat LOGS/New_620_genomes_reformat_genomes_and_anvio_contigDBs.log | grep "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/04_CONTIGS_DB/G_" | sed -e 's!/workspace/jmarkwelchlab/P_0003_Neisseriaceae/04_CONTIGS_DB/G_!!g' | sed -e 's/-contigs.db,//g' > contigs_check.txt

# remove empty spaces
sed -i 's/[[:space:]]//g' contigs_check.txt

# The following code will tell you which row is missing in the contigs_check.txt
# Create an array with the expected sequence
expected_sequence=($(seq -w 0001 0620))

# Read the lines from your file into an array
readarray -t file_lines < contigs_check.txt

# Iterate through the expected sequence
for i in "${expected_sequence[@]}"; do
    # Check if the current number is in the file lines
    if [[ ! " ${file_lines[*]} " =~ " $i " ]]; then
        echo "Missing row: $i"
    fi
done


#Missing row: 0243


# Now find the error info for that contig. Looks like a disk error...lame!
grep -A 50 "Name .........................................: G_0243" LOGS/New_620_genomes_reformat_genomes_and_anvio_contigDBs.log 

# check db info since there is a file for it
anvi-db-info 04_CONTIGS_DB/G_0243-contigs.db
# Says configure error!

# rebuild the contig db
anvi-gen-contigs-database -f 03_GENOMES_EDITED/${genome}.fa -n G_0243 -o 04_CONTIGS_DB/G_0243-contigs.db -T 5 


# Had to migrate to version 21 for anvio 8
clusterize -n 5 -l LOGS/New_620_genomes_migrate_v21.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/migrate_contigs_db_v21.sh 


```



##### 2.7 Run hmms to annotate with marker gene DBs (Bac_71, rRNAs Arch and Bac); tRNAs; GTDB taxonomy

```{bash, eval=FALSE new genomes}

clusterize -n 5 -l LOGS/new_genomes_anvio_hmms_trnas_gtdb.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/anvio_hmms_trnas_gtdb.sh


cat LOGS/new_genomes_anvio_hmms_trnas_gtdb.log | grep -A 5 "Done with Bacteria_71 🎊" | grep "Number of hits in annotation dict" | wc -l
# Shows 620 completed, as expected
```

Config Error: An anvi'o function needs 'tRNAscan-SE' to be installed on your system, but it
              doesn't seem to appear in your path :/ If you are certain you have it on your
              system (for instance you can run it by typing 'tRNAscan-SE' in your terminal
              window), you may want to send a detailed bug report. Sorry!


Config Error: OK. It is very likley that if you run `anvi-setup-scg-taxonomy` first you will
              be golden. Because even though anvi'o found the directory for taxonomy
              headquarters, your setup seems to be missing 22 of 22 databases required for
              everything to work with the current genes configuration of this class (sources
              say this is a record, FYI).
              

##### 2.8 Contigs stats for each genome using anvio.

This is an important step to make sure that each and every contig has the same hmms annotations. Otherwise there will be issues downstream. 


```{bash, eval=FALSE new genomes}

mkdir 19_Contig_db_stats/OLD
mv 19_Contig_db_stats/*stats 19_Contig_db_stats/OLD/
mv 19_Contig_db_stats/Contig_bacteria_71_summary.txt 19_Contig_db_stats/OLD/

clusterize -n 1 -l LOGS/new_genomes_check_anvio_contigDB_hmms.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/check_anvio_contigDB_hmms.sh

```

##### 2.9 HOMD names, ITEMS, Contig paths file


```{bash new genomes }

# Upload metadata file
scp -r /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/NCBI_DATASETS/02_P_0003_Neisseriaceae.csv jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/DATA/02_P_0003_Neisseriaceae.csv


clusterize -n 5 -l LOGS/new_genomes_Rename_HOMD_create_ITEMS_Contigs_path_file.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Rename_HOMD_create_ITEMS_Contigs_path_file.sh

```

##### 2.10 Send pangenome IDs to local for adding to metadataa
```{bash, eval=FALSE}

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/DATA/13_P_0003_Neisseriaceae-name_conversions.txt /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/DATA/13_P_0003_Neisseriaceae-name_conversions.txt
```


##### 2.11 CheckM 2 

screen -S qrsh_sesh_2
qrsh -pe allslots 20

module load checkm2
module load clusters/barhal
module load jbpc

```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Data=$mainDIR/$projectID/DATA
nameConversions=$DIR_Data/13_${projectID}-name_conversions.txt
DIR_CheckM=$mainDIR/$projectID/26_CHECKM
DIR_Contigs=$mainDIR/$projectID/03_GENOMES_EDITED

mkdir $DIR_CheckM/BINS_DIR

# copy genomes and change names
while IFS= read -r line
do
orginalName=$( echo "$line" | awk -F'\t' '{print $2}')
newName=$( echo "$line" | awk -F'\t' '{print $1}')
cp $DIR_Contigs/$orginalName.fa $DIR_CheckM/BINS_DIR/$newName.fa
done < $nameConversions


checkm2 predict --threads 5  -x .fa --input $mainDIR/$projectID/26_CHECKM/BINS_DIR/ --output-directory $mainDIR/$projectID/26_CHECKM/CHECKM2/Genomes_620


```

Send results to local machine 
```{bash, eval=FALSE Send CheckM 2 results to local machine }

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/26_CHECKM/CHECKM2/Genomes_620 /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/26_CHECKM/CHECKM2/
```


The following genomes were removed from the data set due to low completeness (< 90%) and high contamination (> 5%) as estimated by CheckM 2:

Genome_ID   Completeness    Contamination
K_potus_str_3_SID_1128_id_GCA_022870985_1   80.73   4.29
N_weixii_str_10022_id_GCA_002327085_1   85.22   2.8
K_kingae_str_AA392_id_GCA_030180345_1   89.92   4.41
N_lisongii_str_ZJ104_id_GCA_021728505_1   100   9.4
N_elongata_str_Nel_M001_id_GCA_018437425_1    99.61   8.77

```{bash, eval=FALSE Remove incomplete and contaminated genomes from 620 genome data set}

# copy contigs path file
GENOMES=$mainDIR/$projectID/DATA/$projectID-contig_paths.txt
GENOMES_decontaminated=$mainDIR/$projectID/DATA/$projectID-decontaminated-contig_paths.txt
cp $GENOMES $GENOMES_decontaminated

# remove selected genomes listed above
awk 'FNR==NR{a[$1];next} !($1 in a)' DATA/checkM_decontaminated_incomplete_list.txt $GENOMES > $GENOMES_decontaminated

# make meta data file to add to pangenome
layersADD_decontaminated=DATA/$projectID-decontaminated-add_info.items.txt
ITEMS=${projectID}-add_info.items.txt
head -n1 $ITEMS > $layersADD_decontaminated
for genomeTypeID in `cat $GENOMES_decontaminated`
do
cat $ITEMS | grep "$genomeTypeID" >> $layersADD_decontaminated
done

G_0620_name_conv=DATA/13_P_0003_Neisseriaceae-name_conversions.txt
G_0615_name_conv=DATA/G_0615-name_conversions.txt
# remove selected genomes listed above
awk 'FNR==NR{a[$1];next} !($1 in a)' DATA/checkM_decontaminated_incomplete_list.txt $G_0620_name_conv > $G_0615_name_conv


# write pangenome description txt file for anvi-pan-genome --description flag
PAN_DES_decontaminated=DATA/description_decontaminated_pangenome.txt

echo "This pangenome is of Neisseria, Kingella, Eikenella and Simonsiella species. It's purpose is as an initial pangenome that will provide some information about how genomes cluster, which will be used downstream to filter redunadant genomes or thos ethat cluster with non-human taxa. Genomes with less than 90% completion and greater than 3% contamination estimated by checkM were removed." > $PAN_DES_decontaminated

```


##### 2.12. Meningitidis & Gonorrhoeae

###### 2.12.1 Dowload and process genomes

*See file meningitidis_gonorrhoeae_NCBI_genome_dereplication.Rmd*

###### 2.12.2 CheckM2 on Men/Gno genomes

module load checkm2
module load clusters/barhal
module load jbpc

```{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab

clusterize -n 20 -m jgiacomini@forsyth.org -l LOGS/checkm2_initial_run.log checkm2 predict --threads 20  -x .fa --input $mainDIR/$projectID/26_CHECKM/BINS_DIR/ --output-directory $mainDIR/$projectID/26_CHECKM/CHECKM2/

mkdir $mainDIR/$projectID/26_CHECKM/CHECKM2/MEN_GNO
clusterize -n 20 -m jgiacomini@forsyth.org -l LOGS/checkm2_men_gno.log checkm2 predict --threads 20  -x .fa --input $mainDIR/$projectID/03_GENOMES_EDITED/MEN_GNO_GENOMES --output-directory $mainDIR/$projectID/26_CHECKM/CHECKM2/MEN_GNO

```


```{bash send checkm2 reuslts to local}

mkdir  /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/26_CHECKM  /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/26_CHECKM/CHECKM2/

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/26_CHECKM/CHECKM2/quality_report.tsv /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/26_CHECKM/CHECKM2/quality_report.tsv


scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/26_CHECKM/CHECKM2/MEN_GNO/quality_report.tsv /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/26_CHECKM/CHECKM2/MEN_GNO_quality_report.tsv


scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/DATA/meningitidis_gonorrhoeae-name_conversions.txt /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/DATA/meningitidis_gonorrhoeae-name_conversions.txt
```

###### 2.12.3 Dereplicate Men/Gno genomes 

De-replicate of Neisseria meningitidis and Neisseria gonorrhoeae genomes.

Please see file "meningitidis_gonorrhoeae_NCBI_genome_dereplication.Rmd" for explanation of the code used to download and process the genomes. 

At this point all 3317 genomes were successfully downloaded, unzipped, reformatted and contigs databases were generated for each. The next step is dereplication using Anvio and FastANI.

```{bash, eval=FALSE}
anvi-dereplicate-genomes -e $MEN_GNO_GENOMES -o $DIR_Derep/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI --skip-fasta-report --program fastANI --similarity-threshold 0.98 --cluster-method simple_greedy --representative-method centrality --num-threads 20 --log-file $mainDIR/$projectID/LOGS/meningitidis_gonorrhoeae-anvi-dereplicate-fastANI_98.log

#Check
cat $mainDIR/$projectID/LOGS/meningitidis_gonorrhoeae-anvi-dereplicate-fastANI_98.log | grep "query" | wc -l
```

Run mode .....................................: fastANI

CITATION

Anvi'o will use 'fastANI' by Jain et al. (DOI: 10.1038/s41467-018-07641-9) to
compute ANI. If you publish your findings, please do not forget to properly
credit their work.

[fastANI] Kmer size ..........................: 16
[fastANI] Fragment length ....................: 3,000
[fastANI] Min fraction of alignment ..........: 0.25
[fastANI] Num threads to use .................: 20
[fastANI] Log file path ......................: /workspace/jmarkwelchlab/P_0003_Neisseriaceae/LOGS/meningitidis_gonorrhoeae-anvi-dereplicate-fastANI_98.log

[10 Sep 23 23:21:49 fastANI] Many to Many ...

fastANI similarity metric ....................: calculated
Number of genomes considered .................: 3,317
Number of redundant genomes ..................: 3,296
Final number of dereplicated genomes .........: 21

ANI RESULTS

* Matrix and clustering of 'ani' written to output directory
* Matrix and clustering of 'alignment fraction' written to output directory
* Matrix and clustering of 'mapping fragments' written to output directory
* Matrix and clustering of 'total fragments' written to output directory


There were 3,317 genomes (1055 for N. gonorrhoeae and 2262 for N. meningitidis). I used FastANI, with default settings, via the anvio program anvi-dereplicate-genomes to dereplicate based on a 98% ANI similarity threshold. Using pyANI instead of fastANI would have taken significantly longer. The results are a major reduction in the number of genomes - 3,296 were considered redundant, resulting in a total of 21 clusters. There are 20 clusters for N. meningitidis, one of which contains 2094 genomes, and there is only a single cluster for all 1055 N. gonorrhoeae genomes.  
 
Overall, I am happy to see such a major reduction in the number of genomes, but I wonder if it is any concern that there is only one N. gonorrhoeae cluster. This is not an oral species, so it likely does not matter for mapping. And, more importantly, the Neisseria, Eikenella, Kingella and Simonsiella phylogenies that I built previously using 26 complete N. gonorrhoeae genomes show a monophyletic group for both N. gonorrhoeae. Additionally, the metaphlan results show zero abundance of N. gonorrhoeae for all samples.

As to which genome to pick -- in Anthony's work with Strep, we biased the selection toward (1) closed genomes (complete genomes in NCBI), (2) the type strain, and (3) genomes that can be bought from culture collections, even if not the type strain.

There is one genome in RefSeq assembled from type strain material (N_gonorrhoeae_str_DSM_9188_id_GCA_003315235_1). It is not considered to be a complete genome in NCBI because it has 74 scaffolds with a few gaps throughout. There are a small number of complete genomes that come from the NCTC culture collection (N = 4). Of those, CheckM2 estimates 100% completion for one (N_gonorrhoeae_str_NCTC13799_id_GCA_900186935_1 ) and 99.9% for the other three. All four were estimated to have 0.11% contamination. 
For meningitidis, there are two RefSeq genomes assembled from type strain material, both of which are considered complete by NCBI (N_meningitidis_str_NCTC10025_id_GCA_900638555_1 and N_meningitidis_str_PartJ_Nmeningitidis_RM8376_id_GCA_022869645_1). 


```{bash, eval=FALSE}

# print number of clusters, number of genomes per cluster, and chosen genomes
cat 15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI/CLUSTER_REPORT.txt | awk '{print $1, $2, $3}'

# Make sure there are no other N. gonorrhoeae genomes nested with N meningitidis clusters
cat 15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI/CLUSTER_REPORT.txt | awk 'NR>3' | grep "gonorrhoeae" | wc -l

# Where is the type strain genome for N_meningitidis? Its in cluster_000001
cat 15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI/CLUSTER_REPORT.txt | grep "N_meningitidis_str_NCTC10025_id_GCA_900638555_1" | awk '{print $1}'

# The other type strain genome is also in cluster_000001
cat 15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI/CLUSTER_REPORT.txt | grep "N_meningitidis_str_PartJ_Nmeningitidis_RM8376_id_GCA_022869645_1" | awk '{print $1}'


# send results to local machine for inclusion into metadata file. 
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI/CLUSTER_REPORT.txt /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI-CLUSTER_REPORT.txt

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI/SIMILARITY_SCORES/fastANI_ani.txt /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI_ani.txt


mkdir /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/MEN_GON_SIMILARITY_SCORES
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI/SIMILARITY_SCORES/ /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/MEN_GON_SIMILARITY_SCORES/

```

The above information satisfies how to handle the two large clusters, but we need a strategy to sort through the other N meningitidis clusters to pick genomes by (1) closed genomes (complete genomes in NCBI), (2) the type strain, and (3) genomes that can be bought from culture collections.For the strain that we would select, we should also inspect how it fares by the average similarity metric.

I first generated a txt file for each cluster that contain a comma seperated list of genomes included in the cluster. I then transformed the comma-separated elements in the cluster_00000X.txt files into a column; We can use the tr command to replace commas with newline characters.
```{bash, eval=FALSE}

cd /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/Men_Gon_clusters/

for cluster in 000001 000002 000003 000004 000005 000006 000008 000009 000016 000018
do

# First extract the list of genomes per each cluster
cat /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI-CLUSTER_REPORT.txt | grep "cluster_$cluster"  |awk -F"\t" '{print$4}' > cluster_$cluster.txt

# Then transform the comma-separated elements in the cluster_00000X.txt files into a column;
# We can use the tr command to replace commas with newline characters.
cat cluster_$cluster.txt | tr ',' '\n' > transformed_cluster_$cluster.txt
done


```

```{r}
# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/MEN_GON_SIMILARITY_SCORES/fastANI_ani.txt", header = TRUE)

# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/MEN_GON_SIMILARITY_SCORES/fastANI_ani.newick")

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)

long_df$rounded_z <- round(long_df$z, digits = 2)

# plot
plot<-ggplot(long_df, aes(key,y)) +
  geom_tile(aes(fill = rounded_z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.98,
                       limits =c(0.97, 1),
                       na.value="darkblue")+
  #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x= element_blank()) 


ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/MEN_GON_SIMILARITY_SCORES/Small_MEN_GON_ANI_heatmap_rounded.pdf", plot = plot, width = 11, height = 8)
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/MEN_GON_SIMILARITY_SCORES/Small_MEN_GON_ANI_heatmap.pdf", plot = plot, width = 11, height = 8)


# rows <- as.data.frame(df_newick$tip.label)
# height=nrow(rows) *0.15
# width=height*1.2
#ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/MEN_GON_SIMILARITY_SCORES/MEN_GON_ANI_heatmap.pdf", plot = plot, width = width, height = height, limitsize = FALSE)


```

Now merge each list with the metadata file, keeping only the rows that match the GCA IDs (need to extract) in the list
```{r}
# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

metadata <- read.csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/DATA/10_13_2023_FINAL_merged_datasets_and_genbank_metadata_tab.csv", header = TRUE)
  
ani <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI_ani.txt", header = TRUE, sep = "\t")

clusterIDs <- list("000001", "000002", "000003", "000004", "000005", "000006", "000008", "000009", "000016", "000018")

for (clusterID in clusterIDs) {
  
    list <- read.table(paste0("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/Men_Gon_clusters/transformed_cluster_",clusterID,".txt"), header = FALSE)
    
    # For each pangenome ID in the list, extract the GCA ID
    list <- list %>% 
      mutate(assembly_accession = gsub(".*_id_", "", V1))
    
    list$assembly_accession <- gsub("_1", ".1", list$assembly_accession)
    list$assembly_accession <- gsub("_2", ".2", list$assembly_accession)
    
    # Now merge with the metadata file based on assembly_accession
    merged_list <- merge(metadata, list, by = "assembly_accession")
    
    # save
    write.csv(merged_list, paste0("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/Men_Gon_clusters/transformed_cluster_",clusterID,"_with_metadata.csv"), row.names = FALSE, quote = FALSE)
    
    # Also, for each cluster, subset the master ANI matrix
    ani_filtered <- ani %>% 
      filter(key %in% list$V1)
      
    # Extract the list of pangenome IDs from the 'list' dataframe
    selected_columns <- as.character(list$V1)
    
    # Make sure to include the "key" column as well, since you want to retain it
    selected_columns <- c("key", selected_columns)
    
    # Subset the 'ani' dataframe using the selected columns
    ani_filtered_2 <- ani_filtered[, selected_columns, drop = FALSE]
    
    # save ani results
    write.table(ani_filtered_2, paste0("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/Men_Gon_clusters/transformed_cluster_",clusterID,"_ANI_matrix.txt"), row.names = FALSE, quote = FALSE, sep = "\t")

    
    wide_df2 <- ani_filtered_2[,-1]
    rownames(wide_df2) <- ani_filtered_2[,1]

    # convert to matrix for heirachrical clustering
    wide_matrix <- as.matrix(wide_df2)
    
    # calculate Bray-Curtis distance among samples
    dist_df <- vegan::vegdist(wide_matrix, method = "bray")
    
    #Replace na values with 0 using is.na()
    dist_df[dist_df=="NaN"]<-0
    
    # Hierarchical clustering using Complete Linkage
    hc <- hclust(dist_df, method = "complete" )
      
    # transform to longform 
    cols2<- ncol(ani_filtered_2) 
    long_df <- reshape2::melt(ani_filtered_2,
                              id.vars=c("key"),
                              measure.vars=colnames(ani_filtered_2[2:cols2]),
                              variable.name="y",
                              value.name="z")
    
    
    # reorder genomes for triples plot based on hclust
    genomes_order <- hc$labels[hc$order]
    long_df$key <- factor(long_df$key, levels = genomes_order)  
    long_df$y <- factor(long_df$y, levels = genomes_order)  
    
    # plot
    plot<-ggplot(long_df, aes(key,y)) +
      geom_tile(aes(fill = z)) + 
      scale_fill_gradient2(low = "darkblue",
                           mid = "white",
                           high = "darkred",
                           midpoint = 0.99,
                           limits =c(0.98, 1))+
      #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
      ylab("") +  
      xlab("") + 
      theme_classic() + 
      theme(axis.text.x = element_text(size = 4, angle = 45, hjust = 1, color = "black"),
            axis.text.y = element_text(size = 4, color = "black"),
            axis.ticks.y = element_line(linewidth = 0.5),
            axis.ticks.x=element_line(linewidth = 0.5)) 
    
    # rows <- as.data.frame(wide_matrix)
    # height=nrow(rows) *0.15
    # width=height*1.2
    
    # save plot
    ggsave(file = paste0("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/Men_Gon_clusters/transformed_cluster_",clusterID,"_ANI_heatmap.pdf"), plot = plot, width = 11, height = 8, limitsize = FALSE)

}


```


The chosen N. gonorrhoeae genome for cluster 000002 shares a minimum of 98.91% ANI and a max of 99.85% with all other genomes in it's respective cluster. 



###### 2.12.4 Dereplication @ 99% ANI for N. gonorrhoaeae
```{bash, eval=FALSE}

mainDIR=/workspace/jmarkwelchlab
projectID=P_0003_Neisseriaceae
OUT=$mainDIR/$projectID/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_99_dereplication_fastANI
DIR_ANI=$mainDIR/$projectID/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_98_dereplication_fastANI/SIMILARITY_SCORES

anvi-dereplicate-genomes -o $OUT --ani-dir $DIR_ANI --skip-fasta-report --program fastANI --similarity-threshold 0.99 --cluster-method simple_greedy --representative-method centrality --num-threads 20 --log-file $mainDIR/$projectID/LOGS/meningitidis_gonorrhoeae_ANI_99_dereplication_fastANI.log

#Check
cat $OUT/CLUSTER_REPORT.txt | wc -l

# send to local
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/15_DE_REPLICATION/meningitidis_gonorrhoeae_ANI_99_dereplication_fastANI /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/
```



###### 2.12.5 Annotate with marker gene DBs (Bac_71, rRNAs Arch and Bac); tRNAs; GTDB taxonomy

```{bash, eval=FALSE update contigs dbs}
# Get the list of 21 genome IDs for the slected genomes
awk 'NR==FNR{a[$0]; next} $1 in a' DATA/Men_gon_selected_pangenome_IDs.txt $MEN_GNO_nameConversions | awk '{print $2}'> DATA/Men_gon_selected_genome_IDs.txt

for x in `cat DATA/Men_gon_selected_genome_IDs.txt`
do
cp 04_CONTIGS_DB/MEN_GNO_GENOMES/$x-contigs.db 04_CONTIGS_DB/MEN_GNO_GENOMES/$x-v20-contigs.db
anvi-migrate --migrate-safely 04_CONTIGS_DB/MEN_GNO_GENOMES/$x-contigs.db
done

# run hmms
for genome in `cat DATA/Men_gon_selected_genome_IDs.txt`
do
anvi-run-hmms -c 04_CONTIGS_DB/MEN_GNO_GENOMES/${genome}-contigs.db -T 10
done

```

We need to add these genomes to the master set, but the genome IDs need to be changed so that they don't overlap with the other non-men and non-gon genomes (i.e., the G_0615 set).

We can copy them into the main 04_CONTIGS_DB/ directory with their changed names.

First I used nano to manually edit the DATA/Men_gon_selected_genome_IDs.txt to include a column with new genome IDs ranging from 621 to 643. I saved the new file as DATA/Men_gon_selected_new_genome_IDs.txt. There is a header  old_ID and new_ID


```{bash, eval=FALSE}

# We need to change the project_names to reflect new genome IDs 
for x in `cat DATA/Men_gon_selected_genome_IDs.txt`
do
new_ID=$(cat DATA/Men_gon_selected_new_genome_IDs.txt | grep "$x" | awk '{print $2}')
cp 04_CONTIGS_DB/MEN_GNO_GENOMES/$x-contigs.db 04_CONTIGS_DB/$new_ID-contigs.db
anvi-db-info --self-key project_name --self-value "$new_ID" 04_CONTIGS_DB/$new_ID-contigs.db --just-do-it
done

```


We also need to update the fasta files with the new genome IDs so that we can build the bac 71 phylogeny
```{bash}

for x in `cat DATA/Men_gon_selected_genome_IDs.txt`
do
new_ID=$(cat DATA/Men_gon_selected_new_genome_IDs.txt | grep "$x" | awk '{print $2}')
cp 03_GENOMES_EDITED/MEN_GNO_GENOMES/$x.fa 03_GENOMES_EDITED/$new_ID.fa
cp 03_GENOMES_EDITED/MEN_GNO_GENOMES/$x.report.tsv 03_GENOMES_EDITED/$new_ID.report.tsv
done

```



###### 2.12.6 Add Men/Gon genomes to G_0615 dataset to make a G_0636 dataset


We need to add the genomes to the contig paths file:
```{bash, eval=FALSE }

# copy contigs path file
GENOMES_decontaminated=$mainDIR/$projectID/DATA/$projectID-decontaminated-contig_paths.txt
GENOMES_G_0636=$mainDIR/$projectID/DATA/$projectID-G_0636-contig_paths.txt
cp $GENOMES_decontaminated $GENOMES_G_0636

# Add new genomes to file
#1 . update name conversions file 

new_IDs=DATA/Men_gon_selected_new_genome_IDs.txt 
selected_pan_IDs=DATA/Men_gon_selected_pangenome_IDs.txt
MEN_GNO_nameConversions=DATA/meningitidis_gonorrhoeae-name_conversions.txt
selected_name_conv=DATA/meningitidis_gonorrhoeae-selected_name_conversions.txt
selected_new_name_conv=DATA/meningitidis_gonorrhoeae-selected_new_name_conversions.txt

# Get pangenome and genome IDs for selected genomes only.
awk 'NR==FNR{a[$0]; next} $1 in a' $selected_pan_IDs $MEN_GNO_nameConversions | awk '{print $1,$2}'> $selected_name_conv

# Change the second column of the first file "$selected_name_conv" so that the old_ID is replaced with the new_ID for each respective row.
awk 'NR==FNR {id[$1]=$2; next} $2 in id {$2=id[$2]} 1' OFS=' ' "$new_IDs" "$selected_name_conv" | awk 'BEGIN {OFS="\t"} {$1=$1} 1' > $selected_new_name_conv


# 2. make contigs path file
selected_new_name_conv=DATA/meningitidis_gonorrhoeae-selected_new_name_conversions.txt
new_IDs=DATA/Men_gon_selected_new_genome_IDs.txt 
MEN_GON_GENOMES=DATA/meningitidis_gonorrhoeae_selected-contig_paths.txt
echo -e 'name\tcontigs_db_path' > $MEN_GON_GENOMES
for genome in `cat $new_IDs | awk 'NR>1{print $2}'`
do
cat $selected_new_name_conv | grep "$genome" | awk -v workPath="$PWD" 'BEGIN{FS=OFS="\t"}{print $1,workPath"/04_CONTIGS_DB/"$2"-contigs.db"}' >> $MEN_GON_GENOMES
done

# 3. add new selected men/gon contigs path file to the G_0615 path file
GENOMES_decontaminated=DATA/${projectID}-decontaminated-contig_paths.txt
MEN_GON_GENOMES=DATA/meningitidis_gonorrhoeae_selected-contig_paths.txt
GENOMES_G_0636=DATA/${projectID}-G_0636-contig_paths.txt
cat $GENOMES_decontaminated <(tail -n +2 $MEN_GON_GENOMES) > $GENOMES_G_0636


# make ITEMS file for meningitidis_gonorrhoeae_selected
ITEMS_MEN_GON=DATA/meningitidis_gonorrhoeae_selected-add_info.items.txt
seqidHOMD=/workspace/jmarkwelchlab/HOMD_INFO/SEQID_info.txt
selected_new_name_conv=DATA/meningitidis_gonorrhoeae-selected_new_name_conversions.txt
echo -e "item\tGenome_ID\tSpecies\tAssembly_ID\tAssembly_ID_norm\tStrain\tGenome_in_HOMD\tHOMD_ID\tG_ID" > $ITEMS_MEN_GON
for gcaID in `cat $selected_new_name_conv | cut -f1 | awk -F'_id_' '{print $2}' | rev | sed -e 's/_/./' | rev `
do
gcaID_ed=$(echo $gcaID | sed -e 's/\./_/')
itemsID=$(grep "$gcaID_ed" $selected_new_name_conv | cut -f1 | awk -F'_str_' -v OFS="\t" '{print $0,$0,$1}')
strainID=$( grep "$gcaID_ed" $selected_new_name_conv | cut -f1 | awk -F'_str_' -v OFS="\t" '{print $2}' | awk -F'_id_' -v OFS="\t" '{print $1}' )
genomeHOMD=$( grep "$gcaID" $seqidHOMD)
if [ -z "$genomeHOMD" ]
then
inHOMD="no"
hmtID="NA"
else
inHOMD="yes"
hmtID=$( echo "$genomeHOMD"| awk 'BEGIN{FS=OFS="\t"}{print "HMT_"$2}')
fi
gID=$( grep "$gcaID_ed" $nameConversions | cut -f2 )
echo -e "$itemsID\t$gcaID_ed\t$gcaID\t$strainID\t$inHOMD\t$hmtID\t$gID" >> $ITEMS_MEN_GON
done

# concatenated men/gon items file with the G_0620 items file
ITEMS=${projectID}-add_info.items.txt
ITEMS_MEN_GON=DATA/meningitidis_gonorrhoeae_selected-add_info.items.txt
G_0636_ITEMS=DATA/G_0636-add_info.items.txt
cat $ITEMS <(tail -n +2 $ITEMS_MEN_GON) > $G_0636_ITEMS


# make new meta data file to add to pangenome
layersADD_G_0636=DATA/$projectID-G_0636-add_info.items.txt
G_0636_ITEMS=DATA/G_0636-add_info.items.txt
head -n1 $G_0636_ITEMS > $layersADD_G_0636
for genomeTypeID in `cat $GENOMES_G_0636`
do
cat $G_0636_ITEMS | grep "$genomeTypeID" >> $layersADD_G_0636
done

# Update name conversions
selected_new_name_conv=DATA/meningitidis_gonorrhoeae-selected_new_name_conversions.txt
G_0615_name_conv=DATA/G_0615-name_conversions.txt
G_0636_name_conv=DATA/G_0636-name_conversions.txt
# Add selected genomes listed above to name conversion file
cat $G_0615_name_conv $selected_new_name_conv > $G_0636_name_conv
```

##### 2.13 Bac_71 Phylogeny

For phylogenomic analyses we used a collection of bacteria single-copy core genes curated by Anvi'o developers and based on searches of ∼12000 bacterial high-quality genomes from (https://doi.org/10.1093/bioinformatics/btz188) and modified to remove Ribosomal_S20p, PseudoU_synth_1, Exonuc_VII_S, 5-FTHF_cyc-lig, YidD and Peptidase_A8 from the collection (as they were exceptionally redundant or rare among MAGs from various habitats), and added Ribosomal_S3_C, Ribosomal_L5, Ribosomal_L2 to make it more compatible with Hug et al's (https://www.nature.com/articles/nmicrobiol201648) set of ribosomal proteins.


To generate phylogenetic trees we used the Anvi'o program ‘anvi-get-sequences-for-hmm-hits’ using parameters (1) ‘--align-with muscle’ to perform alignment of protein sequences using MUSCLE (doi:10.1093/nar/gkh340 http://www.drive5.com/muscle), (2) ‘--concatenate-genes’ to concatenate separately aligned and concatenated gene sequences, (3) ‘--returnbest-hit’ to return only the most significant hit when a single HMM profile had multiple hits in one genome, (4) `--get-aa-sequences’ to output amino-acid sequence, and (5) ‘--hmmsources Bacteria_71’ to use the Bacteria 71 collection to search for genes. We used ‘--min-num-bins-gene-occurs’ to ensure that only genes that occur in at least 50% of the genomes were used for the analysis. All 71 genes from the Bacteria 71 collection were subsequrntly used for the phylogenetic tree analysis. We trimmed alignments using trimAl (Capella-Gutiérrez, Silla Martínez & Gabaldón, 2009) with the setting ‘-gt 0.5’ to remove all positions that were gaps in more than 50% of sequences, and computed maximum likelihood phylogenetic trees using IQ-TREE (Nguyen et al., 2015) with the ‘WAG’ general matrix model (Whelan & Goldman, 2001). 


To root trees we used an type strain genome for Burkholderia cepacia (same class as Nesseriaceae family; different order Burkholderiales)


Make sure you are in the anvio-8 environment:

module load anvio/8-conda
module load clusters/barhal
module load jbpc
module load muscle
module load trimal
module load iqtree/1.6.12


###### 2.13.1 G_0615

1. Add outgroup fasta file ()
```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Phylo=$mainDIR/$projectID/14_PHYLOGENOMICS

# retrieve genome from ncbi
wget -q -P $DIR_Phylo https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/009/586/235/GCA_009586235.1_ASM958623v1/GCA_009586235.1_ASM958623v1_genomic.fna.gz

# unzip it
gunzip $DIR_Phylo/GCA_009586235.1_ASM958623v1_genomic.fna.gz

# rename it
mv $DIR_Phylo/GCA_009586235.1_ASM958623v1_genomic.fna $DIR_Phylo/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1.fa

#reformat fasta file (simplify deflines)
minContigSIZE=300
anvi-script-reformat-fasta -l $minContigSIZE -o $DIR_Phylo/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1_reformatted.fa --simplify-names --prefix Burkholderia_cepacia --seq-type NT -r $DIR_Phylo/Burkholderia_cepacia $DIR_Phylo/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1.fa

# make contigs db - anvio uses prodigal to predict ORFs
anvi-gen-contigs-database -f $DIR_Phylo/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1_reformatted.fa -o $DIR_Phylo/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1.db -T 4

#annotate marker genes
anvi-run-hmms -c $DIR_Phylo/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1.db

# check 
anvi-db-info $DIR_Phylo/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1.db

# make new contigs path file
GENOMES_decontaminated=$mainDIR/$projectID/DATA/P_0003_Neisseriaceae-decontaminated-contig_paths.txt
GENOMES_decontaminated_with_outgroup=$mainDIR/$projectID/DATA/$projectID-decontaminated-outgroup-contig_paths.txt
cp $GENOMES_decontaminated $GENOMES_decontaminated_with_outgroup

# manually add out-group to contigs path file
echo -e 'Burkholderia_cepacia_str_BC16_id_GCA_009586235_1\t/workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1.db' >> $GENOMES_decontaminated_with_outgroup
```

2. Extract and concatenate aa sequences for bacteria_71 collection
```{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Phylo=$mainDIR/$projectID/14_PHYLOGENOMICS
GENOMES_decontaminated_with_outgroup=$mainDIR/$projectID/DATA/$projectID-decontaminated-outgroup-contig_paths.txt
num_genomes=620
min_num_genomes=$( expr $num_genomes / 2 )


anvi-get-sequences-for-hmm-hits --e $GENOMES_decontaminated_with_outgroup --hmm-source Bacteria_71 --min-num-bins-gene-occurs $min_num_genomes --get-aa-sequences --concatenate-genes --return-best-hit --align-with muscle -o $DIR_Phylo/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences

```

3. Build trees for each group with trimal/IQtree
```{bash, eval=FALSE}

# trimal removes all positions in the alignment with gaps in 50% or more of the sequences
trimal -in $DIR_Phylo/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences -out $DIR_Phylo/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences.clean.fa -gt 0.50 

# build ML tree with WAG model and bootstrap supoprt
iqtree -s $DIR_Phylo/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences.clean.fa -nt AUTO -m WAG -bb 1000 -o "Burkholderia_cepacia_str_BC16_id_GCA_009586235_1"

```

Analysis results written to:
  IQ-TREE report:                /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences.clean.fa.iqtree
  Maximum-likelihood tree:       /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences.clean.fa.treefile
  Likelihood distances:          /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences.clean.fa.mldist

Ultrafast bootstrap approximation results written to:
  Split support values:          /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences.clean.fa.splits.nex
  Consensus tree:                /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences.clean.fa.contree
  Screen log file:               /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences.clean.fa.log

4. Plot trees in r on local machine
```{bash, eval=FALSE}
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/
```


Scale bar indicates the number of substitutions per site.
```{r plot bac 71 phylogeny}
library(dendextend)
library(ape)
library(dplyr)
library(phytools)
library(phylogram)

MLtree<-ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_decontaminated_with_outgroup_bac71_sequences.clean.fa.contree")

dend_MLtree <- ape::chronos(MLtree)


pdf("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_decontaminated_with_outgroup_bac71_IQTree.pdf",
    width = 10, height = 30)
plot(dend_MLtree, cex = 0.25, edge.width = 0.5)
nodelabels(text = MLtree$node.label,node=2:MLtree$Nnode+Ntip(MLtree),frame="none",adj=c(1.2,-0.5), cex = 0.2, col = "red")
add.scale.bar()

dev.off() 


```


Make sure to loan anvio 8 module:

module load anvio
module load clusters/barhal
module load jbpc

###### 2.13.2 G_0636

1. Add outgroup fasta file ()
```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab

# make new contigs path file
GENOMES_G_0636=$mainDIR/$projectID/DATA/$projectID-G_0636-contig_paths.txt
GENOMES_G_0636_with_outgroup=$mainDIR/$projectID/DATA/$projectID-G_0636-outgroup-contig_paths.txt
cp $GENOMES_G_0636 $GENOMES_G_0636_with_outgroup

# manually add out-group to contigs path file
echo -e 'Burkholderia_cepacia_str_BC16_id_GCA_009586235_1\t/workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1.db' >> $GENOMES_G_0636_with_outgroup
```

2. Extract and concatenate aa sequences for bacteria_71 collection
```{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Phylo=$mainDIR/$projectID/14_PHYLOGENOMICS
GENOMES_G_0636_with_outgroup=$mainDIR/$projectID/DATA/$projectID-G_0636-outgroup-contig_paths.txt
num_genomes=636
min_num_genomes=$( expr $num_genomes / 2 )

anvi-get-sequences-for-hmm-hits --e $GENOMES_G_0636_with_outgroup --hmm-source Bacteria_71 --min-num-bins-gene-occurs $min_num_genomes --get-aa-sequences --concatenate-genes --return-best-hit --align-with muscle -o $DIR_Phylo/G_0636_with_outgroup_bac71_sequences

```

Genes occurred in at least 318 of 637 bins (70) : Ribosomal_L14, SecY, Ribosomal_L6, TsaE, Ribosomal_L3, Ribosomal_L32p, Ribosomal_S2, tRNA-synt_1d, SmpB, Ribosomal_S20p,Chorismate_synt, Ribosomal_L27A, RsfS, Exonuc_VII_L, Ribosomal_S3_C, Ribosomal_L9_C, ATP-synt, Ribosomal_S15,Ribosomal_L28, Ribosomal_S8, Ribosomal_L20, Ribosomal_L23, YajC, PGK, Ribosomal_L2, Adenylsucc_synt, Ribosomal_L35p,ATP-synt_A, Ribosom_S12_S23, SecG, AICARFT_IMPCHas, RNA_pol_L, ADK, Ribosomal_L1, Ribosomal_L16, Ribosomal_L22, SecE,EF_TS, OSCP, Ribosomal_S19, Ribosomal_L27, RuvX, Ribosomal_S6, ribosomal_L24, tRNA_m1G_MT, RBFA, Ribosomal_S17, GrpE,Ribosomal_S13, Ribosomal_S11, Ham1p_like, UPF0054, Ribosomal_L17, Ribosomal_L18p, RecO_C, Ribosomal_S7, Ribosomal_L19,Ribosomal_L29, Ribosomal_L21p, Ribosomal_S10, RNA_pol_Rpb6, Ribosomal_L13, eIF-1a, Pept_tRNA_hydro, Ribosomal_S16, RRF,Ribosomal_L5, Ribosomal_S9, IPPT, Ribosomal_L4

Genes that are no more in the analysis (1) ...: Ribonuclease_P

3. Build trees for each group with trimal/IQtree
```{bash, eval=FALSE}

# trimal removes all positions in the alignment with gaps in 50% or more of the sequences
trimal -in $DIR_Phylo/G_0636_with_outgroup_bac71_sequences -out $DIR_Phylo/G_0636_with_outgroup_bac71_sequences.clean.fa -gt 0.50 

# build ML tree with WAG model and bootstrap supoprt
iqtree -s $DIR_Phylo/G_0636_with_outgroup_bac71_sequences.clean.fa -nt AUTO -m WAG -bb 1000 -o "Burkholderia_cepacia_str_BC16_id_GCA_009586235_1"

```
Analysis results written to:
  IQ-TREE report:                /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.iqtree
  Maximum-likelihood tree:       /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.treefile
  Likelihood distances:          /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.mldist

Ultrafast bootstrap approximation results written to:
  Split support values:          /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.splits.nex
  Consensus tree:                /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.contree
  Screen log file:               /workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.log


4. Plot trees in r on local machine
```{bash, eval=FALSE}
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.contree /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.contree
```


Scale bar indicates the number of substitutions per site.
```{r plot bac 71 phylogeny}
library(dendextend)
library(ape)
library(dplyr)
library(phytools)
library(phylogram)

# Standard tree
MLtree<-ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.contree")
pdf("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_ML_tree_with_outgroup_bac71_IQTree.pdf",
    width = 10, height = 30)
plot(MLtree, cex = 0.25, edge.width = 0.5)
nodelabels(text = MLtree$node.label,node=2:MLtree$Nnode+Ntip(MLtree),frame="none",adj=c(1.2,-0.5), cex = 0.2, col = "red")
add.scale.bar()
dev.off() 

library("ggtree")
ggtree(MLtree, layout="circular")

#######################################################################################################################
#######################################################################################################################

# Chronos tree
MLtree<-ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.contree")
dend_MLtree <- ape::chronos(MLtree)
pdf("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_IQTree.pdf",
    width = 10, height = 30)
plot(dend_MLtree, cex = 0.25, edge.width = 0.5)
nodelabels(text = MLtree$node.label,node=2:MLtree$Nnode+Ntip(MLtree),frame="none",adj=c(1.2,-0.5), cex = 0.2, col = "red")
add.scale.bar()
dev.off() 




#######################################################################################################################
#######################################################################################################################
# Circular tree

library(ggtree)
library(ape)
library(dplyr)

# Read the tree
MLtree <- ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac71_sequences.clean.fa.contree")

# Grouping by genera
groupInfo <- split(MLtree$tip.label, gsub("_\\w+", "", MLtree$tip.label))
MLtree <- groupOTU(MLtree, groupInfo)

# Grouping by species
Species_groupInfo <- split(MLtree$tip.label, gsub("_", ".", gsub("^(.*?_.*?_).*", "\\1", MLtree$tip.label)))
names(Species_groupInfo) <- gsub(".$", "", names(Species_groupInfo))

# Create a mapping between each tip and its species group
species_mapping <- data.frame(species = rep(names(Species_groupInfo), sapply(Species_groupInfo, length)),
                              tip = unlist(Species_groupInfo))


# Create the tree visualization with tip labels colored by genera
p <- ggtree(MLtree, aes(color=group), layout="fan", size=0.2, open.angle=15) +
  geom_tiplab(size=0.2)

# Merge the data using dplyr
data <- left_join(p$data, species_mapping, by = c("label" = "tip"))

# Group by species and calculate the median node for each species
clade_labels_data <- data %>%
  group_by(species) %>%
  summarise(node = round(median(node, na.rm = TRUE), digits = 0),
            clade_label_angle = median(angle, na.rm = TRUE))

# Add the species group labels to the clades using the updated clade_labels_data
p2 <- p + geom_cladelab(data = clade_labels_data,
                       mapping = aes(node = node, label = species, angle = clade_label_angle),
                       geom = "text",
                       align = TRUE,
                       horizontal = FALSE,
                       offset = -0.12,
                       angle = 45)

ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_circular_bac_71_tree_ver_3.pdf", p2, width = 11, height = 8)



```

Where do sp. genomes cluster?

I manually inspected the bac 71 phylogeny and produced this summary figure:
Many paced within species groups.

count   place
1  N. meningitidis
1   N. polysacchareae
1   N. cinera
34    N. subflava group
6   N. mucosa group
2   N. oralis
2   N. Brasilliensis
1   N.dumasiana
1   N. wadsworthii (maybe)
1   N. elongate
1   N. sp. HMT-020
2   N. sp. solitary
2   K. sp. solitary
3   E. corrodens
8   E. exigua
2   E. glucosivorans (maybe)
1   N. sp. major outgroup

```{r}

data_str <- "count\tplace
1\tN. meningitidis
1\tN. polysacchareae
1\tN. cinera
34\tN. subflava group
6\tN. mucosa group
2\tN. oralis
2\tN. Brasilliensis
1\tN.dumasiana
1\tN. wadsworthii (maybe)
1\tN. elongate
1\tN. sp. HMT-020
2\tN. sp. solitary
2\tK. sp. solitary
3\tE. corrodens
8\tE. exigua
2\tE. glucosivorans (maybe)
1\tN. sp. major outgroup
8\tOthers (non-human)"

df <- read.table(text=data_str, header=TRUE, sep="\t")

sp_plot <- ggplot(df, aes(x = reorder(place, -count), y = count)) +
  geom_bar(stat = "identity", position = position_dodge(0.9), fill = "steelblue") +
  scale_y_continuous(expand = c(0,0), limits = c(0, 40)) +
  geom_text(aes(label=count, y=count + max(count)*0.02), vjust=0) +
  ylab("Frequency") + xlab("Placement") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 50, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"))

print(sp_plot)

ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_with_outgroup_bac_71_SP_placement_summary.pdf", sp_plot, width = 5, height = 3)

```

##### 2.14 Pangenome 

###### 2.14.1 G_0615 pangenome - Longer Run Time using NCBI blastp & pyANI

1. Using NCBI blastp for amino acid sequence search 
2. Using pyANI for pairwise ANI comparisons.


Added the flag --I-know-this-is-not-a-good-idea since there are a whopping 615 genomes!!!
```{bash, eval=FALSE}

mkdir /workspace/jmarkwelchlab/$projectID/09_PANGENOME/${projectID}_G_0615_decontaminated-pangenome

clusterize -n 10 -m jgiacomini@forsyth.org -l LOGS/G_0615_decontaminated_pangenome.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/decontaminated_pangenome.sh


```


###### 2.14.2 G_0615 pangenome - Shorten Run Time: Diamond & fastANI

1. Use Diamond. Running blastp is significantly slower than DIAMOND, but in some cases, slightly
more sensitive. Per Anvio, they are unsure about whether the slight increase in sensitivity justifies the significant increase in run time.

2. Use FastANI instead of PyANI

If you publish results from this workflow, please do not forget to cite DIAMOND
(doi:10.1038/nmeth.3176), unless you use it with --use-ncbi-blast flag, and MCL
(http://micans.org/mcl/ and doi:10.1007/978-1-61779-361-5_15)

```{bash, eval=FALSE}

# copy script
cp /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/decontaminated_pangenome.sh /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/DIAMOND_decontaminated_pangenome.sh

# edit script to
# 1. change amino acid sequence search to DIAMOND by removing --use-ncbi-blast flag 
# 2. change PanProject to ${projectID}_G_0615_decontaminated-pangenome_DIAMOND
# 3. change GENOMES_decontaminated_pangenome_DB location
nano /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/DIAMOND_decontaminated_pangenome.sh

mkdir /workspace/jmarkwelchlab/$projectID/09_PANGENOME/${projectID}_G_0615_decontaminated-pangenome_DIAMOND

clusterize -n 10 -m jgiacomini@forsyth.org -l LOGS/DIAMOND_G_0615_decontaminated_pangenome.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/DIAMOND_decontaminated_pangenome.sh

# check
cat /automounts/workspace/workspace/jmarkwelchlab/P_0003_Neisseriaceae/G_0615_pangenome_FASTANI_log | grep " query" | wc -l
```

###### 2.14.3 G_0636 pangenome

Took 3 days to build pan and run ANI analysis
```{bash, eval=FALSE}
# write pangenome description txt file for anvi-pan-genome --description flag
PAN_DES_G_0636=DATA/description_G_0636_pangenome.txt

echo "This pangenome is of Neisseria, Kingella, Eikenella and Simonsiella species. There are 636 genomes in this pangenome. Genomes have greater than 90% completion and less than 3% contamination estimated by checkM2. Meningitidis and gonorrhoeae genomes were deprelicated at a 98% ANI treshold prior to pangenome construction." > $PAN_DES_G_0636

projectID=P_0003_Neisseriaceae
mkdir /workspace/jmarkwelchlab/$projectID/09_PANGENOME/${projectID}_G_0636-pangenome

clusterize -n 10 -m jgiacomini@forsyth.org -l LOGS/G_0636_pangenome.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/G_0636_pangenome.sh

```


###### 2.14.4 G_0636 Gene-cluster frequencies tree 

* Note that we can't complete this task until ANI is complete because anvio does not allow writing operations during journaling *


Extract gene-cluster frequencies newick tree from pangenome:
```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/${projectID}_G_0636-pangenome
GENOMES_G_0636_DB=$DIR_Pangenome/P_0003_Neisseriaceae_G_0636-pangenome-GENOMES.db
PAN_DB=$DIR_Pangenome/${projectID}_G_0636-pangenome-RESULTS/${projectID}_G_0636-pangenome-PAN.db


anvi-export-misc-data -p $PAN_DB --target-data-table layer_orders -o $DIR_Pangenome/${projectID}-G_0636-pangenome-layers_order

cat $DIR_Pangenome/${projectID}-G_0636-pangenome-layers_order | grep 'gene_cluster frequencies'| awk -F"\t" '{print $3}' >  $DIR_Pangenome/G_0636_pangenome_gene_cluster_frequencies_newick
```

Send tree to local
```{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/${projectID}_G_0636-pangenome
DIR_local=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae

# Pan tree
scp -r jgiacomini@evol5.mbl.edu:$DIR_Pangenome/G_0636_pangenome_gene_cluster_frequencies_newick $DIR_local/09_PANGENOME/G_0636/G_0636_pangenome_gene_cluster_frequencies_newick
```


```{r}

# Circular tree

library(ggtree)
library(ape)
library(dplyr)

# Read the tree
MLtree <- ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/G_0636/G_0636_pangenome_gene_cluster_frequencies_newick")

# Grouping by genera
groupInfo <- split(MLtree$tip.label, gsub("_\\w+", "", MLtree$tip.label))
MLtree <- groupOTU(MLtree, groupInfo)

# Grouping by species
Species_groupInfo <- split(MLtree$tip.label, gsub("_", ".", gsub("^(.*?_.*?_).*", "\\1", MLtree$tip.label)))
names(Species_groupInfo) <- gsub(".$", "", names(Species_groupInfo))

# Create a mapping between each tip and its species group
species_mapping <- data.frame(species = rep(names(Species_groupInfo), sapply(Species_groupInfo, length)),
                              tip = unlist(Species_groupInfo))


# Create the tree visualization with tip labels colored by genera
p <- ggtree(MLtree, aes(color=group), layout="fan", size=0.2, open.angle=15) +
  geom_tiplab(size=0.2)

# Merge the data using dplyr
data <- left_join(p$data, species_mapping, by = c("label" = "tip"))

# Group by species and calculate the median node for each species
clade_labels_data <- data %>%
  group_by(species) %>%
  summarise(node = round(median(node, na.rm = TRUE), digits = 0),
            clade_label_angle = median(angle, na.rm = TRUE))

# Add the species group labels to the clades using the updated clade_labels_data
p2 <- p + geom_cladelab(data = clade_labels_data,
                       mapping = aes(node = node, label = species, angle = clade_label_angle),
                       geom = "text",
                       align = TRUE,
                       horizontal = FALSE,
                       offset = 0,
                       angle = 45)

ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_pan_gene_cluster_freq_tree.pdf", p2, width = 11, height = 8)



```

##### 2.15 SCG phylogeny

###### 2.15.1 G_0615
```{bash, eval=FALSE Get sequences for pangenome single copy core genes and build tree}

projectID=Neisseriaceae
mainDIR=/Users/home/SPECIES_LEVEL_PANGENOMES
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME
GENOMES_decontaminated_pangenome_DB=$DIR_Pangenome/P_0003_Neisseriaceae-decontaminated-pangenome-GENOMES.db
PAN_DB=$DIR_Pangenome/P_0003_Neisseriaceae-decontaminated-pangenome-PAN.db
N_genomes=473

anvi-get-sequences-for-gene-clusters -g $GENOMES_decontaminated_pangenome_DB \
                                     -p $PAN_DB \
                                     -o $DIR_Pangenome/single_copy_core_genes-fasta \
                                     --max-num-genes-from-each-genome 1 \
                                     --min-num-genomes-gene-cluster-occurs $N_genomes \
                                     --concatenate-gene-clusters 
                                     
iqtree -s $DIR_Pangenome/single_copy_core_genes-fasta -nt AUTO -m WAG -bb 1000 

```

ANVIO:

Based on --min-num-genomes-gene-cluster-occurs 473, --max-num-genomes-gene-
cluster-occurs 473, --min-num-genes-from-each-genome 0, --max-num-genes-from-
each-genome 1, --min-functional-homogeneity-index -1.000, --max-functional-
homogeneity-index 1.000, --min-geometric-homogeneity-index -1.000, --max-
geometric-homogeneity-index 1.000, --min-combined-homogeneity-index -1.000,
--max-combined-homogeneity-index 1.000 (some of these may be default values, no
need to panic).

All gene clusters (31489) ....................: GC_00017627, GC_00028105, GC_00024223, (... 31486 more (`--debug` will show all))
Gene clusters that passed the filter (80) ....: GC_00000522, GC_00000614, GC_00000521, (... 77 more (`--debug` will show all))
Genes clusters that failed the filter (31409) : GC_00017627, GC_00028105, GC_00015906, (... 31406 more (`--debug` will show all))

Your filters resulted in 80 gene clusters that contain a total of 37840 genes.
for downstream analyses. Just so you know.


IQTREE:

WARNING: 237 sites contain only gaps or ambiguous characters.
Alignment has 473 sequences with 20371 columns, 12623 distinct patterns
10024 parsimony-informative, 1333 singleton sites, 9014 constant sites



Scale bar indicates the number of substitutions per site.
```{r plot pangenome single copy core gene phylogeny}
library(dendextend)
library(ape)
library(dplyr)
library(phytools)
library(phylogram)

MLtree<-ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/single_copy_core_genes-fasta.contree")

dend_MLtree <- ape::chronos(MLtree)

dend_MLtree_rooted_1 <- root(MLtree, 1, resolve.root = TRUE)
is.rooted(dend_MLtree_rooted_1)

dend_MLtree_rooted_2 <- root(MLtree, outgroup = "N_sp_str_HSC_16F19_id_GCA_024171525_1", resolve.root = TRUE)
is.rooted(dend_MLtree_rooted_2)



# un-rooted
pdf("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/single_copy_core_genes_phylogeny_unrooted.pdf",
    width = 20, height = 25)
plot(MLtree, cex = 0.25, edge.width = 0.5)
nodelabels(text = MLtree$node.label,node=2:MLtree$Nnode+Ntip(MLtree),frame="none",adj=c(1.2,-0.5), cex = 0.2, col = "red")
add.scale.bar()

dev.off() 

##### rooted 1
pdf("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/single_copy_core_genes_phylogeny_rooted_1.pdf",
    width = 20, height = 25)
plot(dend_MLtree_rooted_1, cex = 0.25, edge.width = 0.5)
nodelabels(text = MLtree$node.label,node=2:MLtree$Nnode+Ntip(MLtree),frame="none",adj=c(1.2,-0.5), cex = 0.2, col = "red")
add.scale.bar()

dev.off() 

##### rooted 2
pdf("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/single_copy_core_genes_phylogeny_rooted_2.pdf",
    width = 20, height = 25)
plot(dend_MLtree_rooted_2, cex = 0.25, edge.width = 0.5)
nodelabels(text = MLtree$node.label,node=2:MLtree$Nnode+Ntip(MLtree),frame="none",adj=c(1.2,-0.5), cex = 0.2, col = "red")
add.scale.bar()

dev.off() 


```

###### 2.15.2 G_0636

Get sequences for pangenome single copy core genes and build tree


With that N_sp_str_HSC_16F19_id_GCA_024171525_1 genome that is an outrgroup. This genome will likely significantly reduce the number of core genes. 
```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/${projectID}_G_0636-pangenome
GENOMES_G_0636_DB=$DIR_Pangenome/P_0003_Neisseriaceae_G_0636-pangenome-GENOMES.db
PAN_DB=$DIR_Pangenome/${projectID}_G_0636-pangenome-RESULTS/${projectID}_G_0636-pangenome-PAN.db
N_genomes=636

anvi-get-sequences-for-gene-clusters -g $GENOMES_G_0636_DB \
                                     -p $PAN_DB \
                                     -o $DIR_Pangenome/G_0636_single_copy_core_genes-fasta \
                                     --max-num-genes-from-each-genome 1 \
                                     --min-num-genomes-gene-cluster-occurs $N_genomes \
                                     --concatenate-gene-clusters 
                                     
# trimal removes all positions in the alignment with gaps in 50% or more of the sequences
trimal -in $DIR_Pangenome/G_0636_single_copy_core_genes-fasta -out $DIR_Pangenome/G_0636_single_copy_core_genes-fasta.clean.fa -gt 0.50 

# build ML tree with WAG model and bootstrap support rooted by N. sp. genome that was placed as outgroup in bac71 tree
iqtree -s $DIR_Pangenome/G_0636_single_copy_core_genes-fasta.clean.fa -nt AUTO -m WAG -bb 1000 -o "N_sp_str_HSC_16F19_id_GCA_024171525_1"

```
Your filters resulted in 61 gene clusters that contain a total of 38796 genes.

Analysis results written to:
  IQ-TREE report:                /workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0636-pangenome/G_0636_single_copy_core_genes-fasta.clean.fa.iqtree
  Maximum-likelihood tree:       /workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0636-pangenome/G_0636_single_copy_core_genes-fasta.clean.fa.treefile
  Likelihood distances:          /workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0636-pangenome/G_0636_single_copy_core_genes-fasta.clean.fa.mldist

Ultrafast bootstrap approximation results written to:
  Split support values:          /workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0636-pangenome/G_0636_single_copy_core_genes-fasta.clean.fa.splits.nex
  Consensus tree:                /workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0636-pangenome/G_0636_single_copy_core_genes-fasta.clean.fa.contree
  Screen log file:               /workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0636-pangenome/G_0636_single_copy_core_genes-fasta.clean.fa.log

Send tree to local 
```{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/${projectID}_G_0636-pangenome
DIR_local=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae


scp -r jgiacomini@evol5.mbl.edu:$DIR_Pangenome/G_0636_single_copy_core_genes-fasta.clean.fa.contree $DIR_local/09_PANGENOME/G_0636/G_0636_single_copy_core_genes-fasta.clean.fa.contree
```


```{r}

# Circular tree

library(ggtree)
library(ape)
library(dplyr)

# Read the tree
MLtree <- ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/G_0636/G_0636_single_copy_core_genes-fasta.clean.fa.contree")

# Grouping by genera
groupInfo <- split(MLtree$tip.label, gsub("_\\w+", "", MLtree$tip.label))
MLtree <- groupOTU(MLtree, groupInfo)

# Grouping by species
Species_groupInfo <- split(MLtree$tip.label, gsub("_", ".", gsub("^(.*?_.*?_).*", "\\1", MLtree$tip.label)))
names(Species_groupInfo) <- gsub(".$", "", names(Species_groupInfo))

# Create a mapping between each tip and its species group
species_mapping <- data.frame(species = rep(names(Species_groupInfo), sapply(Species_groupInfo, length)),
                              tip = unlist(Species_groupInfo))


# Create the tree visualization with tip labels colored by genera
p <- ggtree(MLtree, aes(color=group), layout="fan", size=0.2, open.angle=15) +
  geom_tiplab(size=0.2, color = "black")

# Merge the data using dplyr
data <- left_join(p$data, species_mapping, by = c("label" = "tip"))

# Group by species and calculate the median node for each species
clade_labels_data <- data %>%
  group_by(species) %>%
  summarise(node = round(median(node, na.rm = TRUE), digits = 0),
            clade_label_angle = median(angle, na.rm = TRUE))

# Add the species group labels to the clades using the updated clade_labels_data
p2 <- p + geom_cladelab(data = clade_labels_data,
                       mapping = aes(node = node, label = species, angle = clade_label_angle),
                       geom = "text",
                       align = TRUE,
                       horizontal = FALSE,
                       offset = 0.1,
                       angle = 45) + #geom_text(aes(label=node), size = 0.2, color = "black") +
  geom_hilight(node=702, fill="purple", extend=0.1, alpha = 0.25) +
  geom_hilight(node=699, fill="gold", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=684, fill="green", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=821, fill="blue", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=896, fill="red", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=873, fill="red", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=876, fill="lightgreen", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=962, fill="steelblue", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=869, fill="brown", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=954, fill="aquamarine", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=223, fill="gray", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=979, fill="darkgreen", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1020, fill="pink", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1040, fill="yellow", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1019, fill="yellow", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=370, fill="yellow", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=392, fill="yellow", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1071, fill="burlywood", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1072, fill="cyan", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=428, fill="cyan", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=427, fill="gray", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1085, fill="magenta", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1174, fill="darkorange", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1214, fill="blue3", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1219, fill="darkorchid4", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1248, fill="darksalmon", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1241, fill="chartreuse", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=1257, fill="antiquewhite4", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=833, fill="cornflowerblue", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=829, fill="deeppink4", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=832, fill="red3", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=642, fill="goldenrod1", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=664, fill="magenta", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=676, fill="yellow", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=674, fill="gray", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=673, fill="gray", extend = 0.1, alpha = 0.25) +
  geom_hilight(node=636, fill="red", extend = 0.1, alpha = 0.75)

  



#print(p2)

ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_circular_SCG_tree_node_lables_test.pdf", p2, width = 11, height = 8)



ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_circular_SCG_tree_node_lables.pdf", p2, width = 11, height = 8)




ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0636_circular_SCG_tree.pdf", p2, width = 11, height = 8)



```


##### 2.16 ANI

###### 2.16.1 G_0473 ANI plots

pyANI plots - 473 Neisseria, Kingella, Eikenella and Simonsiella decontaminated genomes

```{bash, eval=FALSE}
#mkdir /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae-decontaminated-pangenome/P_0003_Neisseriaceae-decontaminated-pangenome-RESULTS/ANI_RESULTS/ /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/

```

```{r plot pyANI tree}

# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/ANI_RESULTS/ANIb_percentage_identity.txt", header = TRUE)

# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/ANI_RESULTS/ANIb_percentage_identity.newick")

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)



# plot
plot<-ggplot(long_df, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.95,
                       limits =c(0.90, 1),
                       na.value="darkblue")+
  #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks.y = element_line(size = 1),
        axis.ticks.x=element_line(size = 1)) 

rows <- as.data.frame(df_newick$tip.label)
height=nrow(rows) *0.15
width=height*1.2
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/ANI_RESULTS/Initial_decontaminated_ANI_heatmap.pdf", plot = plot, width = width, height = height, limitsize = FALSE)

```

ANI heatmap for polyphyletic Neisseria group

```{r}

# make list

#row 94 to row 210

neisseria_poly_group <- long_df$key[94:210]

# Subset data frame
long_df_neisseria_poly_group <- long_df %>% 
  filter(key %in% neisseria_poly_group) %>% 
  filter(y %in% neisseria_poly_group)

# plot
plot2<-ggplot(long_df_neisseria_poly_group, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.95,
                       limits =c(0.90, 1),
                       na.value="darkblue")+
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks.y = element_line(size = 1),
        axis.ticks.x=element_line(size = 1)) 

height=nrow(long_df_neisseria_poly_group) *0.15
width=height*1.2
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/ANI_RESULTS/Initial_decontaminated_ANI_heatmap_polyphyletic_neisseria_group.pdf", plot = plot2, width = 25, height = 20)



# Plot distribuiton of ANI values

# Create a ggplot object
dist_of_z <- ggplot(long_df_neisseria_poly_group, aes(x = z)) + 
  geom_histogram(binwidth = 0.01, fill = "blue", color = "black") + 
  labs(x = "Pairwise ANI values", y = "Frequency") +
  scale_y_continuous(expand = c(0,0)) + 
  theme_classic() +
  theme(axis.text = element_text(color = "black"))
dist_of_z

ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/ANI_RESULTS/Initial_decontaminated_ANI_polyphyletic_neisseria_group_distribution.pdf", plot = dist_of_z, width = 4, height = 3)


```

Order ANI plot by pangenome gene cluster frequencies tree
```{r}
# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/ANI_RESULTS/ANIb_percentage_identity.txt", header = TRUE)

# load pangenome tree
df_newick<-ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/decontaminated_pangenome_gene_cluster_frequencies_newick")

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")

mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)


neisseria_poly_group_pan_order <- long_df$key[619:733]

# Subset data frame
long_df_neisseria_poly_group_pan_order <- long_df %>% 
  filter(key %in% neisseria_poly_group_pan_order) %>% 
  filter(y %in% neisseria_poly_group_pan_order)

# plot
plot3<-ggplot(long_df_neisseria_poly_group_pan_order, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.95,
                       limits =c(0.90, 1),
                       na.value="darkblue")+
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks.y = element_line(size = 1),
        axis.ticks.x=element_line(size = 1)) 

  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/ANI_RESULTS/Initial_decontaminated_ANI_heatmap_polyphyletic_neisseria_group_pan_order.pdf", plot = plot3, width = 25, height = 20)
```

###### 2.16.2 G_0473 Dereplication

Using fastANI and/or pyANI (ANIb)

```{bash, eval=FALSE Get dereplication cluster reports}
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME
PanProject=${projectID}-decontaminated-pangenome
PanDir=$DIR_Pangenome/$PanProject
GENOMES_decontaminated_pangenome_DB=$PanDir/${PanProject}-GENOMES.db
PAN_DIR=$PanDir/${PanProject}-RESULTS
PAN_DB=$PanDir/${PanProject}-RESULTS/${PanProject}-PAN.db

GENOMES_decontaminated=$mainDIR/$projectID/DATA/${projectID}-decontaminated-contig_paths.txt
DIR_Derep=$mainDIR/$projectID/15_DE_REPLICATION

# fastANI
anvi-dereplicate-genomes -e $GENOMES_decontaminated -o $DIR_Derep/g_473_initial_decontaminated_ANI_98_dereplication_fastANI --skip-fasta-report --program fastANI --similarity-threshold 0.98 --cluster-method simple_greedy --representative-method centrality --num-threads 10 --log-file $mainDIR/$projectID/LOGS/g_473_initial_decontaminated_anvi-dereplicate-fastANI.log

# pyANI Anib # -e $GENOMES_decontaminated 
anvi-dereplicate-genomes --ani-dir $PAN_DIR/ANI_RESULTS \
  -o $DIR_Derep/g_473_initial_decontaminated_ANI_98_dereplication_pyANIb \
  --skip-fasta-report \
  --program pyANI \
  --method ANIb \
  --similarity-threshold 0.98 \
  --cluster-method simple_greedy \
  --representative-method centrality \
  --num-threads 10 \
  --log-file $mainDIR/$projectID/LOGS/g_473_initial_decontaminated_anvi-dereplicate-pyANI

```

Number of genomes considered .................: 473
Number of redundant genomes ..................: 287                                                                                             
Final number of dereplicated genomes .........: 186


Send fastANI and pyANI dereplication results to local
```{bash, eval=FALSE send to local}

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/15_DE_REPLICATION/ /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/


scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/15_DE_REPLICATION/g_473_initial_decontaminated_ANI_98_dereplication_pyANIb /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/15_DE_REPLICATION/

```


Plot fastANI reuslts (473 genomes)
```{r plot fastANI tree}

# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/15_DE_REPLICATION/g_473_initial_decontaminated_ANI_98_dereplication_fastANI/SIMILARITY_SCORES/fastANI_ani.txt", header = TRUE)

# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/15_DE_REPLICATION/g_473_initial_decontaminated_ANI_98_dereplication_fastANI/SIMILARITY_SCORES/fastANI_ani.newick")

# plot tree
plot(df_newick)

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)



# plot
plot<-ggplot(long_df, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.95,
                       limits =c(0.90, 1))+
  #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks.y = element_line(size = 1),
        axis.ticks.x=element_line(size = 1)) 

rows <- as.data.frame(df_newick$tip.label)
height=nrow(rows) *0.15
width=height*1.2
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/15_DE_REPLICATION/g_473_initial_decontaminated_ANI_98_dereplication_fastANI/SIMILARITY_SCORES/Initial_decontaminated_ANI_heatmap.pdf", plot = plot, width = width, height = height, limitsize = FALSE)


```

###### 2.16.3 G_0615 ANIb plots

Send fastANI results for G_0615 pangenome to local
```{bash, eval=FALSE Run on local}

mkdir /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/${projectID}_G_0615_decontaminated-pangenome
DIR_ANI=$DIR_Pangenome/${projectID}_G_0615_decontaminated-pangenome-RESULTS

scp -r jgiacomini@evol5.mbl.edu:$DIR_ANI/ANI_RESULTS/ /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/
```

```{r plot pyANI tree}

# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/ANI_RESULTS/ANIb_percentage_identity.txt", header = TRUE)

# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/ANI_RESULTS/ANIb_percentage_identity.newick")

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)



# plot
plot<-ggplot(long_df, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.95,
                       limits =c(0.90, 1),
                       na.value="darkblue")+
  #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks.y = element_line(linewidth = 1),
        axis.ticks.x=element_line(linewidth = 1)) 

ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/G_0615_ANIb_heatmap_ordered_by_ANIb_newick.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)

```



```{r Order euclidean complete}
# load ANI data
ani_filtered_2 <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/ANI_RESULTS/ANIb_percentage_identity.txt", header = TRUE)

  wide_df2 <- ani_filtered_2[,-1]
  rownames(wide_df2) <- ani_filtered_2[,1]
  
  # convert to matrix for heirachrical clustering
  wide_matrix <- as.matrix(wide_df2)
  
  # calculate Bray-Curtis distance among samples
  dist_df <- vegan::vegdist(wide_matrix, method = "euclidean")
  
  #Replace na values with 0 using is.na()
  dist_df[dist_df=="NaN"]<-0
  
  # Hierarchical clustering using Complete Linkage
  hc <- hclust(dist_df, method = "complete" )
  
  # transform to longform 
  cols2<- ncol(ani_filtered_2) 
  long_df <- reshape2::melt(ani_filtered_2,
                            id.vars=c("key"),
                            measure.vars=colnames(ani_filtered_2[2:cols2]),
                            variable.name="y",
                            value.name="z")
  
  
  # reorder genomes for triples plot based on hclust
  genomes_order <- hc$labels[hc$order]
  long_df$key <- factor(long_df$key, levels = genomes_order)  
  long_df$y <- factor(long_df$y, levels = genomes_order)  
  
  
  keys <- as.data.frame(levels(long_df$key))
  keys <- keys %>% 
    rename(pangenomeIDs = "levels(long_df$key)") %>% 
    mutate(colors = case_when(grepl('K_kingae', pangenomeIDs) ~ 'gold',
                              grepl('K_sp', pangenomeIDs) ~ 'aquamarine3',
                              grepl('S_muelleri', pangenomeIDs) ~ 'darkmagenta',
                              grepl('K_negevensis', pangenomeIDs) ~ 'gray40',
                              grepl('N_arctica', pangenomeIDs) ~ 'black',
                              grepl('K_denitrificans', pangenomeIDs) ~ 'darkblue',
                              grepl('K_oralis', pangenomeIDs) ~ 'palevioletred1',
                              grepl('K_bonacorsii', pangenomeIDs) ~ 'olivedrab',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'coral',
                              grepl('N_sp', pangenomeIDs) ~ 'blue',
                              grepl('N_montereyensis', pangenomeIDs) ~ 'black',
                              grepl('N_weaveri', pangenomeIDs) ~ 'saddlebrown',
                              grepl('N_iguanae', pangenomeIDs) ~ 'black',
                              grepl('N_weixii', pangenomeIDs) ~ 'black',
                              grepl('N_cinerea', pangenomeIDs) ~ 'cyan',
                              grepl('N_zalophi', pangenomeIDs) ~ 'black',
                              grepl('N_lactamica', pangenomeIDs) ~ 'red',
                              grepl('N_gonorrhoeae', pangenomeIDs) ~ 'burlywood1',
                              grepl('N_meningitidis', pangenomeIDs) ~ 'plum4',
                              grepl('N_bergeri', pangenomeIDs) ~ 'chartreuse',
                              grepl('N_viridiae', pangenomeIDs) ~ 'darkorange1',
                              grepl('N_polysaccharea', pangenomeIDs) ~ 'steelblue',
                              grepl('N_blantyrii', pangenomeIDs) ~ 'wheat4',
                              grepl('N_benedictiae', pangenomeIDs) ~ 'orange',
                              grepl('N_basseii', pangenomeIDs) ~ 'darkseagreen3',
                              grepl('N_uirgultaei', pangenomeIDs) ~ 'yellow3',
                              grepl('N_maigaei', pangenomeIDs) ~ 'lightsalmon',
                              grepl('N_flavescens', pangenomeIDs) ~ 'springgreen',
                              grepl('N_subflava', pangenomeIDs) ~ 'deeppink',
                              grepl('N_perflava', pangenomeIDs) ~ 'goldenrod1',
                              grepl('N_sicca', pangenomeIDs) ~ 'mediumpurple2',
                              grepl('N_mucosa', pangenomeIDs) ~ 'darkred',
                              grepl('N_elongata', pangenomeIDs) ~ 'skyblue',
                              grepl('N_oralis', pangenomeIDs) ~ 'magenta',
                              grepl('N_macacae', pangenomeIDs) ~ 'black',
                              grepl('E_glucosivorans', pangenomeIDs) ~ 'tomato',
                              grepl('E_sp', pangenomeIDs) ~ 'darkgreen',
                              grepl('E_exigua', pangenomeIDs) ~ 'yellow',
                              grepl('E_corrodens', pangenomeIDs) ~ 'midnightblue',
                              grepl('E_halliae', pangenomeIDs) ~ 'hotpink4',
                              grepl('N_brasiliensis', pangenomeIDs) ~ 'palegreen',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'thistle',
                              grepl('K_potus', pangenomeIDs) ~ 'peru',
                              grepl('N_sp_HMT_020', pangenomeIDs) ~ 'firebrick3',
                              grepl('N_bacilliformis', pangenomeIDs) ~ 'slategray4',
                              grepl('N_animalis', pangenomeIDs) ~ 'black',
                              grepl('N_chenwenguii', pangenomeIDs) ~ 'black',
                              grepl('N_lisongii', pangenomeIDs) ~ 'black',
                              grepl('N_animaloris', pangenomeIDs) ~ 'black',
                              grepl('N_dumasiana', pangenomeIDs) ~ 'burlywood3',
                              grepl('N_dentiae', pangenomeIDs) ~ 'cornflowerblue',
                              grepl('N_zoodegmatis', pangenomeIDs) ~ 'black',
                              grepl('N_canis', pangenomeIDs) ~ 'black',
                              grepl('N_musculi', pangenomeIDs) ~ 'black',
                              grepl('N_wadsworthii', pangenomeIDs) ~ 'black',
                              grepl('N_yangbaofengii', pangenomeIDs) ~ 'black',
                              grepl('E_sp_str_NML02_A_017_id_GCA_001648355_1', pangenomeIDs) ~ 'hotpink'))

  
  # First, read in the color data:
  color_data <- keys
  
  # Then, create the plot:
  plot <- ggplot(long_df, aes(key, y)) +
    geom_tile(aes(fill = z)) + 
    scale_fill_gradient2(low = "darkblue",
                         mid = "white",
                         high = "darkred",
                         midpoint = 0.95,
                         limits =c(0.90, 1),
                         na.value="darkblue") +
    ylab("") +  
    xlab("") + 
    theme_classic() +
    theme(axis.text.x = element_text(size = 1, angle = 45, hjust = 1, color = color_data$colors),
          axis.text.y = element_text(size = 1, color = color_data$colors),
          axis.ticks=element_blank())
  


  # save plot
  ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/G_0615_ANIb_heatmap_colors_euclidean_complete.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)
  
  

```

```{r Order euclidean ward}
# load ANI data
ani_filtered_2 <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/ANI_RESULTS/ANIb_percentage_identity.txt", header = TRUE)

  wide_df2 <- ani_filtered_2[,-1]
  rownames(wide_df2) <- ani_filtered_2[,1]
  
  # convert to matrix for heirachrical clustering
  wide_matrix <- as.matrix(wide_df2)
  
  # calculate Bray-Curtis distance among samples
  dist_df <- vegan::vegdist(wide_matrix, method = "euclidean")
  
  #Replace na values with 0 using is.na()
  dist_df[dist_df=="NaN"]<-0
  
  # Hierarchical clustering using Complete Linkage
  hc <- hclust(dist_df, method = "ward.D" )
  
  # transform to longform 
  cols2<- ncol(ani_filtered_2) 
  long_df <- reshape2::melt(ani_filtered_2,
                            id.vars=c("key"),
                            measure.vars=colnames(ani_filtered_2[2:cols2]),
                            variable.name="y",
                            value.name="z")
  
  
  # reorder genomes for triples plot based on hclust
  genomes_order <- hc$labels[hc$order]
  long_df$key <- factor(long_df$key, levels = genomes_order)  
  long_df$y <- factor(long_df$y, levels = genomes_order)  
  
  
  keys <- as.data.frame(levels(long_df$key))
  keys <- keys %>% 
    rename(pangenomeIDs = "levels(long_df$key)") %>% 
    mutate(colors = case_when(grepl('K_kingae', pangenomeIDs) ~ 'gold',
                              grepl('K_sp', pangenomeIDs) ~ 'aquamarine3',
                              grepl('S_muelleri', pangenomeIDs) ~ 'darkmagenta',
                              grepl('K_negevensis', pangenomeIDs) ~ 'gray40',
                              grepl('N_arctica', pangenomeIDs) ~ 'black',
                              grepl('K_denitrificans', pangenomeIDs) ~ 'darkblue',
                              grepl('K_oralis', pangenomeIDs) ~ 'palevioletred1',
                              grepl('K_bonacorsii', pangenomeIDs) ~ 'olivedrab',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'coral',
                              grepl('N_sp', pangenomeIDs) ~ 'blue',
                              grepl('N_montereyensis', pangenomeIDs) ~ 'black',
                              grepl('N_weaveri', pangenomeIDs) ~ 'saddlebrown',
                              grepl('N_iguanae', pangenomeIDs) ~ 'black',
                              grepl('N_weixii', pangenomeIDs) ~ 'black',
                              grepl('N_cinerea', pangenomeIDs) ~ 'cyan',
                              grepl('N_zalophi', pangenomeIDs) ~ 'black',
                              grepl('N_lactamica', pangenomeIDs) ~ 'red',
                              grepl('N_gonorrhoeae', pangenomeIDs) ~ 'burlywood1',
                              grepl('N_meningitidis', pangenomeIDs) ~ 'plum4',
                              grepl('N_bergeri', pangenomeIDs) ~ 'chartreuse',
                              grepl('N_viridiae', pangenomeIDs) ~ 'darkorange1',
                              grepl('N_polysaccharea', pangenomeIDs) ~ 'steelblue',
                              grepl('N_blantyrii', pangenomeIDs) ~ 'wheat4',
                              grepl('N_benedictiae', pangenomeIDs) ~ 'orange',
                              grepl('N_basseii', pangenomeIDs) ~ 'darkseagreen3',
                              grepl('N_uirgultaei', pangenomeIDs) ~ 'yellow3',
                              grepl('N_maigaei', pangenomeIDs) ~ 'lightsalmon',
                              grepl('N_flavescens', pangenomeIDs) ~ 'springgreen',
                              grepl('N_subflava', pangenomeIDs) ~ 'deeppink',
                              grepl('N_perflava', pangenomeIDs) ~ 'goldenrod1',
                              grepl('N_sicca', pangenomeIDs) ~ 'mediumpurple2',
                              grepl('N_mucosa', pangenomeIDs) ~ 'darkred',
                              grepl('N_elongata', pangenomeIDs) ~ 'skyblue',
                              grepl('N_oralis', pangenomeIDs) ~ 'magenta',
                              grepl('N_macacae', pangenomeIDs) ~ 'black',
                              grepl('E_glucosivorans', pangenomeIDs) ~ 'tomato',
                              grepl('E_sp', pangenomeIDs) ~ 'darkgreen',
                              grepl('E_exigua', pangenomeIDs) ~ 'yellow',
                              grepl('E_corrodens', pangenomeIDs) ~ 'midnightblue',
                              grepl('E_halliae', pangenomeIDs) ~ 'hotpink4',
                              grepl('N_brasiliensis', pangenomeIDs) ~ 'palegreen',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'thistle',
                              grepl('K_potus', pangenomeIDs) ~ 'peru',
                              grepl('N_sp_HMT_020', pangenomeIDs) ~ 'firebrick3',
                              grepl('N_bacilliformis', pangenomeIDs) ~ 'slategray4',
                              grepl('N_animalis', pangenomeIDs) ~ 'black',
                              grepl('N_chenwenguii', pangenomeIDs) ~ 'black',
                              grepl('N_lisongii', pangenomeIDs) ~ 'black',
                              grepl('N_animaloris', pangenomeIDs) ~ 'black',
                              grepl('N_dumasiana', pangenomeIDs) ~ 'burlywood3',
                              grepl('N_dentiae', pangenomeIDs) ~ 'cornflowerblue',
                              grepl('N_zoodegmatis', pangenomeIDs) ~ 'black',
                              grepl('N_canis', pangenomeIDs) ~ 'black',
                              grepl('N_musculi', pangenomeIDs) ~ 'black',
                              grepl('N_wadsworthii', pangenomeIDs) ~ 'black',
                              grepl('N_yangbaofengii', pangenomeIDs) ~ 'black',
                              grepl('E_sp_str_NML02_A_017_id_GCA_001648355_1', pangenomeIDs) ~ 'hotpink'))

  
  # First, read in the color data:
  color_data <- keys
  
  # Then, create the plot:
  plot <- ggplot(long_df, aes(key, y)) +
    geom_tile(aes(fill = z)) + 
    scale_fill_gradient2(low = "darkblue",
                         mid = "white",
                         high = "darkred",
                         midpoint = 0.95,
                         limits =c(0.90, 1),
                         na.value="darkblue") +
    ylab("") +  
    xlab("") + 
    theme_classic() +
    theme(axis.text.x = element_text(size = 1, angle = 45, hjust = 1, color = color_data$colors),
          axis.text.y = element_text(size = 1, color = color_data$colors),
          axis.ticks=element_blank())
  


  # save plot
  ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/G_0615_ANIb_heatmap_colors_euclidean_ward.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)
  
  

```


```{r Order maximum complete}
# load ANI data
ani_filtered_2 <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/ANI_RESULTS/ANIb_percentage_identity.txt", header = TRUE)

  wide_df2 <- ani_filtered_2[,-1]
  rownames(wide_df2) <- ani_filtered_2[,1]
  
  # convert to matrix for heirachrical clustering
  wide_matrix <- as.matrix(wide_df2)
  
  # calculate  distance among samples
  dist_df <- vegan::vegdist(wide_matrix, method = "manhattan")
  #dist_df <- dist(wide_matrix, method = "maximum")


  #Replace na values with 0 using is.na()
  dist_df[dist_df=="NaN"]<-0
  
  # Hierarchical clustering using Complete Linkage
  hc <- hclust(dist_df, method = "complete" )
  
  # transform to longform 
  cols2<- ncol(ani_filtered_2) 
  long_df <- reshape2::melt(ani_filtered_2,
                            id.vars=c("key"),
                            measure.vars=colnames(ani_filtered_2[2:cols2]),
                            variable.name="y",
                            value.name="z")
  
  
  # reorder genomes for triples plot based on hclust
  genomes_order <- hc$labels[hc$order]
  long_df$key <- factor(long_df$key, levels = genomes_order)  
  long_df$y <- factor(long_df$y, levels = genomes_order)  
  
  
  keys <- as.data.frame(levels(long_df$key))
  keys <- keys %>% 
    rename(pangenomeIDs = "levels(long_df$key)") %>% 
    mutate(colors = case_when(grepl('K_kingae', pangenomeIDs) ~ 'gold',
                              grepl('K_sp', pangenomeIDs) ~ 'aquamarine3',
                              grepl('S_muelleri', pangenomeIDs) ~ 'darkmagenta',
                              grepl('K_negevensis', pangenomeIDs) ~ 'gray40',
                              grepl('N_arctica', pangenomeIDs) ~ 'black',
                              grepl('K_denitrificans', pangenomeIDs) ~ 'darkblue',
                              grepl('K_oralis', pangenomeIDs) ~ 'palevioletred1',
                              grepl('K_bonacorsii', pangenomeIDs) ~ 'olivedrab',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'coral',
                              grepl('N_sp', pangenomeIDs) ~ 'blue',
                              grepl('N_montereyensis', pangenomeIDs) ~ 'black',
                              grepl('N_weaveri', pangenomeIDs) ~ 'saddlebrown',
                              grepl('N_iguanae', pangenomeIDs) ~ 'black',
                              grepl('N_weixii', pangenomeIDs) ~ 'black',
                              grepl('N_cinerea', pangenomeIDs) ~ 'cyan',
                              grepl('N_zalophi', pangenomeIDs) ~ 'black',
                              grepl('N_lactamica', pangenomeIDs) ~ 'red',
                              grepl('N_gonorrhoeae', pangenomeIDs) ~ 'burlywood1',
                              grepl('N_meningitidis', pangenomeIDs) ~ 'plum4',
                              grepl('N_bergeri', pangenomeIDs) ~ 'chartreuse',
                              grepl('N_viridiae', pangenomeIDs) ~ 'darkorange1',
                              grepl('N_polysaccharea', pangenomeIDs) ~ 'steelblue',
                              grepl('N_blantyrii', pangenomeIDs) ~ 'wheat4',
                              grepl('N_benedictiae', pangenomeIDs) ~ 'orange',
                              grepl('N_basseii', pangenomeIDs) ~ 'darkseagreen3',
                              grepl('N_uirgultaei', pangenomeIDs) ~ 'yellow3',
                              grepl('N_maigaei', pangenomeIDs) ~ 'lightsalmon',
                              grepl('N_flavescens', pangenomeIDs) ~ 'springgreen',
                              grepl('N_subflava', pangenomeIDs) ~ 'deeppink',
                              grepl('N_perflava', pangenomeIDs) ~ 'goldenrod1',
                              grepl('N_sicca', pangenomeIDs) ~ 'mediumpurple2',
                              grepl('N_mucosa', pangenomeIDs) ~ 'darkred',
                              grepl('N_elongata', pangenomeIDs) ~ 'skyblue',
                              grepl('N_oralis', pangenomeIDs) ~ 'magenta',
                              grepl('N_macacae', pangenomeIDs) ~ 'black',
                              grepl('E_glucosivorans', pangenomeIDs) ~ 'tomato',
                              grepl('E_sp', pangenomeIDs) ~ 'darkgreen',
                              grepl('E_exigua', pangenomeIDs) ~ 'yellow',
                              grepl('E_corrodens', pangenomeIDs) ~ 'midnightblue',
                              grepl('E_halliae', pangenomeIDs) ~ 'hotpink4',
                              grepl('N_brasiliensis', pangenomeIDs) ~ 'palegreen',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'thistle',
                              grepl('K_potus', pangenomeIDs) ~ 'peru',
                              grepl('N_sp_HMT_020', pangenomeIDs) ~ 'firebrick3',
                              grepl('N_bacilliformis', pangenomeIDs) ~ 'slategray4',
                              grepl('N_animalis', pangenomeIDs) ~ 'black',
                              grepl('N_chenwenguii', pangenomeIDs) ~ 'black',
                              grepl('N_lisongii', pangenomeIDs) ~ 'black',
                              grepl('N_animaloris', pangenomeIDs) ~ 'black',
                              grepl('N_dumasiana', pangenomeIDs) ~ 'burlywood3',
                              grepl('N_dentiae', pangenomeIDs) ~ 'cornflowerblue',
                              grepl('N_zoodegmatis', pangenomeIDs) ~ 'black',
                              grepl('N_canis', pangenomeIDs) ~ 'black',
                              grepl('N_musculi', pangenomeIDs) ~ 'black',
                              grepl('N_wadsworthii', pangenomeIDs) ~ 'black',
                              grepl('N_yangbaofengii', pangenomeIDs) ~ 'black',
                              grepl('E_sp_str_NML02_A_017_id_GCA_001648355_1', pangenomeIDs) ~ 'hotpink'))

  
  # First, read in the color data:
  color_data <- keys
  
  # Then, create the plot:
  plot <- ggplot(long_df, aes(key, y)) +
    geom_tile(aes(fill = z)) + 
    scale_fill_gradient2(low = "darkblue",
                         mid = "white",
                         high = "darkred",
                         midpoint = 0.95,
                         limits =c(0.90, 1),
                         na.value="darkblue") +
    ylab("") +  
    xlab("") + 
    theme_classic() +
    theme(axis.text.x = element_text(size = 1, angle = 45, hjust = 1, color = color_data$colors),
          axis.text.y = element_text(size = 1, color = color_data$colors),
          axis.ticks=element_blank())
  


  # save plot
  ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/G_0615_ANIb_heatmap_colors_manhattan_complete.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)
  
  

```

```{r Order maximum ward}
# load ANI data
ani_filtered_2 <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/ANI_RESULTS/ANIb_percentage_identity.txt", header = TRUE)

  wide_df2 <- ani_filtered_2[,-1]
  rownames(wide_df2) <- ani_filtered_2[,1]
  
  # convert to matrix for heirachrical clustering
  wide_matrix <- as.matrix(wide_df2)
  
  # calculate  distance among samples
  dist_df <- dist(wide_matrix, method = "maximum")

  #Replace na values with 0 using is.na()
  dist_df[dist_df=="NaN"]<-0
  
  # Hierarchical clustering using Complete Linkage
  hc <- hclust(dist_df, method = "average" )
  
  # transform to longform 
  cols2<- ncol(ani_filtered_2) 
  long_df <- reshape2::melt(ani_filtered_2,
                            id.vars=c("key"),
                            measure.vars=colnames(ani_filtered_2[2:cols2]),
                            variable.name="y",
                            value.name="z")
  
  
  # reorder genomes for triples plot based on hclust
  genomes_order <- hc$labels[hc$order]
  long_df$key <- factor(long_df$key, levels = genomes_order)  
  long_df$y <- factor(long_df$y, levels = genomes_order)  
  
  
  keys <- as.data.frame(levels(long_df$key))
  keys <- keys %>% 
    rename(pangenomeIDs = "levels(long_df$key)") %>% 
    mutate(colors = case_when(grepl('K_kingae', pangenomeIDs) ~ 'gold',
                              grepl('K_sp', pangenomeIDs) ~ 'aquamarine3',
                              grepl('S_muelleri', pangenomeIDs) ~ 'darkmagenta',
                              grepl('K_negevensis', pangenomeIDs) ~ 'gray40',
                              grepl('N_arctica', pangenomeIDs) ~ 'black',
                              grepl('K_denitrificans', pangenomeIDs) ~ 'darkblue',
                              grepl('K_oralis', pangenomeIDs) ~ 'palevioletred1',
                              grepl('K_bonacorsii', pangenomeIDs) ~ 'olivedrab',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'coral',
                              grepl('N_sp', pangenomeIDs) ~ 'blue',
                              grepl('N_montereyensis', pangenomeIDs) ~ 'black',
                              grepl('N_weaveri', pangenomeIDs) ~ 'saddlebrown',
                              grepl('N_iguanae', pangenomeIDs) ~ 'black',
                              grepl('N_weixii', pangenomeIDs) ~ 'black',
                              grepl('N_cinerea', pangenomeIDs) ~ 'cyan',
                              grepl('N_zalophi', pangenomeIDs) ~ 'black',
                              grepl('N_lactamica', pangenomeIDs) ~ 'red',
                              grepl('N_gonorrhoeae', pangenomeIDs) ~ 'burlywood1',
                              grepl('N_meningitidis', pangenomeIDs) ~ 'plum4',
                              grepl('N_bergeri', pangenomeIDs) ~ 'chartreuse',
                              grepl('N_viridiae', pangenomeIDs) ~ 'darkorange1',
                              grepl('N_polysaccharea', pangenomeIDs) ~ 'steelblue',
                              grepl('N_blantyrii', pangenomeIDs) ~ 'wheat4',
                              grepl('N_benedictiae', pangenomeIDs) ~ 'orange',
                              grepl('N_basseii', pangenomeIDs) ~ 'darkseagreen3',
                              grepl('N_uirgultaei', pangenomeIDs) ~ 'yellow3',
                              grepl('N_maigaei', pangenomeIDs) ~ 'lightsalmon',
                              grepl('N_flavescens', pangenomeIDs) ~ 'springgreen',
                              grepl('N_subflava', pangenomeIDs) ~ 'deeppink',
                              grepl('N_perflava', pangenomeIDs) ~ 'goldenrod1',
                              grepl('N_sicca', pangenomeIDs) ~ 'mediumpurple2',
                              grepl('N_mucosa', pangenomeIDs) ~ 'darkred',
                              grepl('N_elongata', pangenomeIDs) ~ 'skyblue',
                              grepl('N_oralis', pangenomeIDs) ~ 'magenta',
                              grepl('N_macacae', pangenomeIDs) ~ 'black',
                              grepl('E_glucosivorans', pangenomeIDs) ~ 'tomato',
                              grepl('E_sp', pangenomeIDs) ~ 'darkgreen',
                              grepl('E_exigua', pangenomeIDs) ~ 'yellow',
                              grepl('E_corrodens', pangenomeIDs) ~ 'midnightblue',
                              grepl('E_halliae', pangenomeIDs) ~ 'hotpink4',
                              grepl('N_brasiliensis', pangenomeIDs) ~ 'palegreen',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'thistle',
                              grepl('K_potus', pangenomeIDs) ~ 'peru',
                              grepl('N_sp_HMT_020', pangenomeIDs) ~ 'firebrick3',
                              grepl('N_bacilliformis', pangenomeIDs) ~ 'slategray4',
                              grepl('N_animalis', pangenomeIDs) ~ 'black',
                              grepl('N_chenwenguii', pangenomeIDs) ~ 'black',
                              grepl('N_lisongii', pangenomeIDs) ~ 'black',
                              grepl('N_animaloris', pangenomeIDs) ~ 'black',
                              grepl('N_dumasiana', pangenomeIDs) ~ 'burlywood3',
                              grepl('N_dentiae', pangenomeIDs) ~ 'cornflowerblue',
                              grepl('N_zoodegmatis', pangenomeIDs) ~ 'black',
                              grepl('N_canis', pangenomeIDs) ~ 'black',
                              grepl('N_musculi', pangenomeIDs) ~ 'black',
                              grepl('N_wadsworthii', pangenomeIDs) ~ 'black',
                              grepl('N_yangbaofengii', pangenomeIDs) ~ 'black',
                              grepl('E_sp_str_NML02_A_017_id_GCA_001648355_1', pangenomeIDs) ~ 'hotpink'))

  
  # First, read in the color data:
  color_data <- keys
  
  # Then, create the plot:
  plot <- ggplot(long_df, aes(key, y)) +
    geom_tile(aes(fill = z)) + 
    scale_fill_gradient2(low = "darkblue",
                         mid = "white",
                         high = "darkred",
                         midpoint = 0.95,
                         limits =c(0.90, 1),
                         na.value="darkblue") +
    ylab("") +  
    xlab("") + 
    theme_classic() +
    theme(axis.text.x = element_text(size = 1, angle = 45, hjust = 1, color = color_data$colors),
          axis.text.y = element_text(size = 1, color = color_data$colors),
          axis.ticks=element_blank())

  # save plot
  ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0615/G_0615_ANIb_heatmap_colors_maximum_average.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)
  
  

```


###### 2.16.4 G_0636 ANI plots

Send fastANI results for G_0636 pangenome to local
```{bash, eval=FALSE Run on local}
mkdir /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/${projectID}_G_0636-pangenome
DIR_ANI=$DIR_Pangenome/${projectID}_G_0636-pangenome-RESULTS

scp -r jgiacomini@evol5.mbl.edu:$DIR_ANI/ANI_RESULTS/ /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636/
```

```{r plot fastANI tree}

# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636/ANI_RESULTS/fastANI_ani.txt", header = TRUE)

# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636/ANI_RESULTS/fastANI_ani.newick")

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)



# plot
plot<-ggplot(long_df, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.95,
                       limits =c(0.90, 1),
                       na.value="darkblue")+
  #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"),
        axis.text.y = element_text(color = "black"),
        axis.ticks.y = element_line(linewidth = 1),
        axis.ticks.x=element_line(linewidth = 1)) 

rows <- as.data.frame(df_newick$tip.label)
height=nrow(rows) *0.15
width=height*1.2
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636/G_0636_ANI_heatmap_ordered_by_ANI_newick.pdf", plot = plot, width = width, height = height, limitsize = FALSE)

```



```{r}
# load ANI data
ani_filtered_2 <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636/ANI_RESULTS/fastANI_ani.txt", header = TRUE)


  wide_df2 <- ani_filtered_2[,-1]
  rownames(wide_df2) <- ani_filtered_2[,1]
  
  # convert to matrix for heirachrical clustering
  wide_matrix <- as.matrix(wide_df2)
  
  # calculate distance among samples
  dist_df <- vegdist(wide_matrix, method = "manhattan")
  #dist_df <- dist(wide_matrix, method = "maximum")
  
  #Replace na values with 0 using is.na()
  dist_df[dist_df=="NaN"]<-0
  
  # Hierarchical clustering using Complete Linkage
  hc <- hclust(dist_df, method = "complete" )
  
  # transform to longform 
  cols2<- ncol(ani_filtered_2) 
  long_df <- reshape2::melt(ani_filtered_2,
                            id.vars=c("key"),
                            measure.vars=colnames(ani_filtered_2[2:cols2]),
                            variable.name="y",
                            value.name="z")
  
  
  # reorder genomes for triples plot based on hclust
  genomes_order <- hc$labels[hc$order]
  long_df$key <- factor(long_df$key, levels = genomes_order)  
  long_df$y <- factor(long_df$y, levels = genomes_order)  
  
  
  keys <- as.data.frame(levels(long_df$key))
  keys <- keys %>% 
    rename(pangenomeIDs = "levels(long_df$key)") %>% 
    mutate(colors = case_when(grepl('K_kingae', pangenomeIDs) ~ 'gold',
                              grepl('K_sp', pangenomeIDs) ~ 'aquamarine3',
                              grepl('S_muelleri', pangenomeIDs) ~ 'darkmagenta',
                              grepl('K_negevensis', pangenomeIDs) ~ 'gray40',
                              grepl('N_arctica', pangenomeIDs) ~ 'black',
                              grepl('K_denitrificans', pangenomeIDs) ~ 'darkblue',
                              grepl('K_oralis', pangenomeIDs) ~ 'palevioletred1',
                              grepl('K_bonacorsii', pangenomeIDs) ~ 'olivedrab',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'coral',
                              grepl('N_sp', pangenomeIDs) ~ 'blue',
                              grepl('N_montereyensis', pangenomeIDs) ~ 'black',
                              grepl('N_weaveri', pangenomeIDs) ~ 'saddlebrown',
                              grepl('N_iguanae', pangenomeIDs) ~ 'black',
                              grepl('N_weixii', pangenomeIDs) ~ 'black',
                              grepl('N_cinerea', pangenomeIDs) ~ 'cyan',
                              grepl('N_zalophi', pangenomeIDs) ~ 'black',
                              grepl('N_lactamica', pangenomeIDs) ~ 'red',
                              grepl('N_gonorrhoeae', pangenomeIDs) ~ 'burlywood1',
                              grepl('N_meningitidis', pangenomeIDs) ~ 'plum4',
                              grepl('N_bergeri', pangenomeIDs) ~ 'chartreuse',
                              grepl('N_viridiae', pangenomeIDs) ~ 'darkorange1',
                              grepl('N_polysaccharea', pangenomeIDs) ~ 'steelblue',
                              grepl('N_blantyrii', pangenomeIDs) ~ 'wheat4',
                              grepl('N_benedictiae', pangenomeIDs) ~ 'orange',
                              grepl('N_basseii', pangenomeIDs) ~ 'darkseagreen3',
                              grepl('N_uirgultaei', pangenomeIDs) ~ 'yellow3',
                              grepl('N_maigaei', pangenomeIDs) ~ 'lightsalmon',
                              grepl('N_flavescens', pangenomeIDs) ~ 'springgreen',
                              grepl('N_subflava', pangenomeIDs) ~ 'deeppink',
                              grepl('N_perflava', pangenomeIDs) ~ 'goldenrod1',
                              grepl('N_sicca', pangenomeIDs) ~ 'mediumpurple2',
                              grepl('N_mucosa', pangenomeIDs) ~ 'darkred',
                              grepl('N_elongata', pangenomeIDs) ~ 'skyblue',
                              grepl('N_oralis', pangenomeIDs) ~ 'magenta',
                              grepl('N_macacae', pangenomeIDs) ~ 'black',
                              grepl('E_glucosivorans', pangenomeIDs) ~ 'tomato',
                              grepl('E_sp', pangenomeIDs) ~ 'darkgreen',
                              grepl('E_exigua', pangenomeIDs) ~ 'yellow',
                              grepl('E_corrodens', pangenomeIDs) ~ 'midnightblue',
                              grepl('E_halliae', pangenomeIDs) ~ 'hotpink4',
                              grepl('N_brasiliensis', pangenomeIDs) ~ 'palegreen',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'thistle',
                              grepl('K_potus', pangenomeIDs) ~ 'peru',
                              grepl('N_sp_HMT_020', pangenomeIDs) ~ 'firebrick3',
                              grepl('N_bacilliformis', pangenomeIDs) ~ 'slategray4',
                              grepl('N_animalis', pangenomeIDs) ~ 'black',
                              grepl('N_chenwenguii', pangenomeIDs) ~ 'black',
                              grepl('N_lisongii', pangenomeIDs) ~ 'black',
                              grepl('N_animaloris', pangenomeIDs) ~ 'black',
                              grepl('N_dumasiana', pangenomeIDs) ~ 'burlywood3',
                              grepl('N_dentiae', pangenomeIDs) ~ 'cornflowerblue',
                              grepl('N_zoodegmatis', pangenomeIDs) ~ 'black',
                              grepl('N_canis', pangenomeIDs) ~ 'black',
                              grepl('N_musculi', pangenomeIDs) ~ 'black',
                              grepl('N_wadsworthii', pangenomeIDs) ~ 'black',
                              grepl('N_yangbaofengii', pangenomeIDs) ~ 'black',
                              grepl('E_sp_str_NML02_A_017_id_GCA_001648355_1', pangenomeIDs) ~ 'hotpink'))

  
  # First, read in the color data:
  color_data <- keys
  
  # Then, create the plot:
  plot <- ggplot(long_df, aes(key, y)) +
    geom_tile(aes(fill = z)) + 
    scale_fill_gradient2(low = "darkblue",
                         mid = "white",
                         high = "darkred",
                         midpoint = 0.95,
                         limits =c(0.90, 1),
                         na.value="darkblue") +
    ylab("") +  
    xlab("") + 
    theme_classic() +
    theme(axis.text.x = element_text(size = 1, angle = 45, hjust = 1, color = color_data$colors),
          axis.text.y = element_text(size = 1, color = color_data$colors),
          axis.ticks=element_blank())
  


  # save plot
  ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636/G_0636_ANI_heatmap_colors_maximum_average.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)
  
  

```



```{r}
# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636/ANI_RESULTS/fastANI_ani.txt", header = TRUE)

# load pangenome gene cluster freq tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/G_0636/G_0636_pangenome_gene_cluster_frequencies_newick")

# order ANI data by pangenome gene cluster freq tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)



keys <- as.data.frame(levels(long_df$key))
  keys <- keys %>% 
    rename(pangenomeIDs = "levels(long_df$key)") %>% 
    mutate(colors = case_when(grepl('K_kingae', pangenomeIDs) ~ 'gold',
                              grepl('K_sp', pangenomeIDs) ~ 'aquamarine3',
                              grepl('S_muelleri', pangenomeIDs) ~ 'darkmagenta',
                              grepl('K_negevensis', pangenomeIDs) ~ 'gray40',
                              grepl('N_arctica', pangenomeIDs) ~ 'black',
                              grepl('K_denitrificans', pangenomeIDs) ~ 'darkblue',
                              grepl('K_oralis', pangenomeIDs) ~ 'palevioletred1',
                              grepl('K_bonacorsii', pangenomeIDs) ~ 'olivedrab',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'coral',
                              grepl('N_sp', pangenomeIDs) ~ 'blue',
                              grepl('N_montereyensis', pangenomeIDs) ~ 'black',
                              grepl('N_weaveri', pangenomeIDs) ~ 'saddlebrown',
                              grepl('N_iguanae', pangenomeIDs) ~ 'black',
                              grepl('N_weixii', pangenomeIDs) ~ 'black',
                              grepl('N_cinerea', pangenomeIDs) ~ 'cyan',
                              grepl('N_zalophi', pangenomeIDs) ~ 'black',
                              grepl('N_lactamica', pangenomeIDs) ~ 'red',
                              grepl('N_gonorrhoeae', pangenomeIDs) ~ 'burlywood1',
                              grepl('N_meningitidis', pangenomeIDs) ~ 'plum4',
                              grepl('N_bergeri', pangenomeIDs) ~ 'chartreuse',
                              grepl('N_viridiae', pangenomeIDs) ~ 'darkorange1',
                              grepl('N_polysaccharea', pangenomeIDs) ~ 'steelblue',
                              grepl('N_blantyrii', pangenomeIDs) ~ 'wheat4',
                              grepl('N_benedictiae', pangenomeIDs) ~ 'orange',
                              grepl('N_basseii', pangenomeIDs) ~ 'darkseagreen3',
                              grepl('N_uirgultaei', pangenomeIDs) ~ 'yellow3',
                              grepl('N_maigaei', pangenomeIDs) ~ 'lightsalmon',
                              grepl('N_flavescens', pangenomeIDs) ~ 'springgreen',
                              grepl('N_subflava', pangenomeIDs) ~ 'deeppink',
                              grepl('N_perflava', pangenomeIDs) ~ 'goldenrod1',
                              grepl('N_sicca', pangenomeIDs) ~ 'mediumpurple2',
                              grepl('N_mucosa', pangenomeIDs) ~ 'darkred',
                              grepl('N_elongata', pangenomeIDs) ~ 'skyblue',
                              grepl('N_oralis', pangenomeIDs) ~ 'magenta',
                              grepl('N_macacae', pangenomeIDs) ~ 'black',
                              grepl('E_glucosivorans', pangenomeIDs) ~ 'tomato',
                              grepl('E_sp', pangenomeIDs) ~ 'darkgreen',
                              grepl('E_exigua', pangenomeIDs) ~ 'yellow',
                              grepl('E_corrodens', pangenomeIDs) ~ 'midnightblue',
                              grepl('E_halliae', pangenomeIDs) ~ 'hotpink4',
                              grepl('N_brasiliensis', pangenomeIDs) ~ 'palegreen',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'thistle',
                              grepl('K_potus', pangenomeIDs) ~ 'peru',
                              grepl('N_sp_HMT_020', pangenomeIDs) ~ 'firebrick3',
                              grepl('N_bacilliformis', pangenomeIDs) ~ 'slategray4',
                              grepl('N_animalis', pangenomeIDs) ~ 'black',
                              grepl('N_chenwenguii', pangenomeIDs) ~ 'black',
                              grepl('N_lisongii', pangenomeIDs) ~ 'black',
                              grepl('N_animaloris', pangenomeIDs) ~ 'black',
                              grepl('N_dumasiana', pangenomeIDs) ~ 'burlywood3',
                              grepl('N_dentiae', pangenomeIDs) ~ 'cornflowerblue',
                              grepl('N_zoodegmatis', pangenomeIDs) ~ 'black',
                              grepl('N_canis', pangenomeIDs) ~ 'black',
                              grepl('N_musculi', pangenomeIDs) ~ 'black',
                              grepl('N_wadsworthii', pangenomeIDs) ~ 'black',
                              grepl('N_yangbaofengii', pangenomeIDs) ~ 'black',
                              grepl('E_sp_str_NML02_A_017_id_GCA_001648355_1', pangenomeIDs) ~ 'hotpink'))

  
  # First, read in the color data:
  color_data <- keys
  
  # Then, create the plot:
  plot <- ggplot(long_df, aes(key, y)) +
    geom_tile(aes(fill = z)) + 
    scale_fill_gradient2(low = "darkblue",
                         mid = "white",
                         high = "darkred",
                         midpoint = 0.95,
                         limits =c(0.90, 1),
                         na.value="darkblue") +
    ylab("") +  
    xlab("") + 
    theme_classic() +
    theme(axis.text.x = element_text(size = 1, angle = 45, hjust = 1, color = color_data$colors),
          axis.text.y = element_text(size = 1, color = color_data$colors),
          axis.ticks=element_blank())
  

rows <- as.data.frame(df_newick$tip.label)
height=nrow(rows) *0.15
width=height*1.2
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636/G_0636_ANI_heatmap_ordered_by_pangenome_newick.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)

```


Use pangenome gene-cluster freq tree ordering above and manually move splits out...
```{r}


# Convert levels to a dataframe
custom_order <- data.frame(key = levels(long_df$key))

# Assuming custom_order is the character vector
part1 <- custom_order[1:199,]
cinera <- custom_order[200:213,]
part3 <- custom_order[214:345,]
part4 <- custom_order[346:nrow(custom_order),]

new_order <- c(part1, part3, cinera, part4)


#Move E. glucosavorans group of three to after E. halliae
# 487:489 to after 476

part1 <- new_order[1:476]
glucosavorans <- new_order[487:489]
part3 <- new_order[477:486]
part4 <- new_order[490:length(new_order)]

new_order_2 <- c(part1, glucosavorans, part3, part4)

# new order
long_df$key <- factor(long_df$key,levels=new_order_2)
long_df$y <- factor(long_df$y, levels=new_order_2)


keys <- as.data.frame(levels(long_df$key))
  keys <- keys %>% 
    rename(pangenomeIDs = "levels(long_df$key)") %>% 
    mutate(colors = case_when(grepl('K_kingae', pangenomeIDs) ~ 'gold',
                              grepl('K_sp', pangenomeIDs) ~ 'aquamarine3',
                              grepl('S_muelleri', pangenomeIDs) ~ 'darkmagenta',
                              grepl('K_negevensis', pangenomeIDs) ~ 'gray40',
                              grepl('N_arctica', pangenomeIDs) ~ 'black',
                              grepl('K_denitrificans', pangenomeIDs) ~ 'darkblue',
                              grepl('K_oralis', pangenomeIDs) ~ 'palevioletred1',
                              grepl('K_bonacorsii', pangenomeIDs) ~ 'olivedrab',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'coral',
                              grepl('N_sp', pangenomeIDs) ~ 'blue',
                              grepl('N_montereyensis', pangenomeIDs) ~ 'black',
                              grepl('N_weaveri', pangenomeIDs) ~ 'saddlebrown',
                              grepl('N_iguanae', pangenomeIDs) ~ 'black',
                              grepl('N_weixii', pangenomeIDs) ~ 'black',
                              grepl('N_cinerea', pangenomeIDs) ~ 'cyan',
                              grepl('N_zalophi', pangenomeIDs) ~ 'black',
                              grepl('N_lactamica', pangenomeIDs) ~ 'red',
                              grepl('N_gonorrhoeae', pangenomeIDs) ~ 'burlywood1',
                              grepl('N_meningitidis', pangenomeIDs) ~ 'plum4',
                              grepl('N_bergeri', pangenomeIDs) ~ 'chartreuse',
                              grepl('N_viridiae', pangenomeIDs) ~ 'darkorange1',
                              grepl('N_polysaccharea', pangenomeIDs) ~ 'steelblue',
                              grepl('N_blantyrii', pangenomeIDs) ~ 'wheat4',
                              grepl('N_benedictiae', pangenomeIDs) ~ 'orange',
                              grepl('N_basseii', pangenomeIDs) ~ 'darkseagreen3',
                              grepl('N_uirgultaei', pangenomeIDs) ~ 'yellow3',
                              grepl('N_maigaei', pangenomeIDs) ~ 'lightsalmon',
                              grepl('N_flavescens', pangenomeIDs) ~ 'springgreen',
                              grepl('N_subflava', pangenomeIDs) ~ 'deeppink',
                              grepl('N_perflava', pangenomeIDs) ~ 'goldenrod1',
                              grepl('N_sicca', pangenomeIDs) ~ 'mediumpurple2',
                              grepl('N_mucosa', pangenomeIDs) ~ 'darkred',
                              grepl('N_elongata', pangenomeIDs) ~ 'skyblue',
                              grepl('N_oralis', pangenomeIDs) ~ 'magenta',
                              grepl('N_macacae', pangenomeIDs) ~ 'black',
                              grepl('E_glucosivorans', pangenomeIDs) ~ 'tomato',
                              grepl('E_sp', pangenomeIDs) ~ 'darkgreen',
                              grepl('E_exigua', pangenomeIDs) ~ 'yellow',
                              grepl('E_corrodens', pangenomeIDs) ~ 'midnightblue',
                              grepl('E_halliae', pangenomeIDs) ~ 'hotpink4',
                              grepl('N_brasiliensis', pangenomeIDs) ~ 'palegreen',
                              grepl('N_shayeganii', pangenomeIDs) ~ 'thistle',
                              grepl('K_potus', pangenomeIDs) ~ 'peru',
                              grepl('N_sp_HMT_020', pangenomeIDs) ~ 'firebrick3',
                              grepl('N_bacilliformis', pangenomeIDs) ~ 'slategray4',
                              grepl('N_animalis', pangenomeIDs) ~ 'black',
                              grepl('N_chenwenguii', pangenomeIDs) ~ 'black',
                              grepl('N_lisongii', pangenomeIDs) ~ 'black',
                              grepl('N_animaloris', pangenomeIDs) ~ 'black',
                              grepl('N_dumasiana', pangenomeIDs) ~ 'burlywood3',
                              grepl('N_dentiae', pangenomeIDs) ~ 'cornflowerblue',
                              grepl('N_zoodegmatis', pangenomeIDs) ~ 'black',
                              grepl('N_canis', pangenomeIDs) ~ 'black',
                              grepl('N_musculi', pangenomeIDs) ~ 'black',
                              grepl('N_wadsworthii', pangenomeIDs) ~ 'black',
                              grepl('N_yangbaofengii', pangenomeIDs) ~ 'black',
                              grepl('E_sp_str_NML02_A_017_id_GCA_001648355_1', pangenomeIDs) ~ 'hotpink'))

  
  # First, read in the color data:
  color_data <- keys
  
  # new order
long_df$key <- factor(long_df$key,levels=new_order_2)
long_df$y <- factor(long_df$y, levels=new_order_2)

# rename z to ANI
long_df <- long_df %>% 
  rename(ANI = "z")
  
  # Then, create the plot:
  plot <- ggplot(long_df, aes(key, y)) +
    geom_tile(aes(fill = ANI)) + 
    scale_fill_gradient2(low = "darkblue",
                         mid = "white",
                         high = "darkred",
                         midpoint = 0.95,
                         limits =c(0.90, 1),
                         na.value="darkblue") +
    ylab("") +  
    xlab("") + 
    theme_classic() +
    theme(axis.text.x = element_text(size = 1, angle = 45, hjust = 1, color = color_data$colors),
          axis.text.y = element_text(size = 1, color = color_data$colors),
          axis.ticks=element_blank())
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0636/G_0636_ANI_heatmap_custom_order.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)

```

##### 2.17 GTDB classification

###### 2.17.1 G_0615 classification
```{bash, eval=FALSE}
screen -S gtdb

conda deactivate # ignore it if it complains
module purge
module load miniconda/3
source /bioware/miniconda3/bashrc 
conda activate /bioware/gtdbtk-2.3.0
gtdbtk check_install

module load clusters/barhal
module load jbpc


# Create the directory.

mkdir 29_GTDBTK/G_0615
mkdir 29_GTDBTK/G_0615/Genomes
mkdir 29_GTDBTK/G_0615/classify_out 
mkdir 29_GTDBTK/G_0615/tmp


projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab

cd $mainDIR/$projectID

# make custom_taxonomy_file for gtdbtk decorate
cat DATA/$projectID-decontaminated-add_info.items.txt | awk -F"\t" 'NR>1 {print $9, $2}' > 29_GTDBTK/G_0615/custom_taxonomy_file.txt

# move genomes to 29_GTDBTK/Genomes directory (moved to qrsh screen session to run this code)
for G_ID in `cat 29_GTDBTK/G_0615/custom_taxonomy_file.txt | awk '{print $1}'`; do
cp 03_GENOMES_EDITED/${G_ID}.fa 29_GTDBTK/G_0615/Genomes/${G_ID}.fa
done

# run script (moved back to gtdb screen session)
# Added --mash_db gtdb-tk-r214.msh
clusterize -n 5 -m jgiacomini@forsyth.org -l LOGS/G_0615_GTDBTK.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/script-gtdbtk-classify_wf.sh


```

```{r}

gtdb_results <- read.table("/workspace/jmarkwelchlab/P_0003_Neisseriaceae/29_GTDBTK/classify_out/gtdbtk.bac120.summary.tsv", header = TRUE, sep = "\t")

meta <- read.table("/workspace/jmarkwelchlab/P_0003_Neisseriaceae/29_GTDBTK/custom_taxonomy_file.txt", header = FALSE)
colnames(meta) <- c("G_ID", "pangenome_ID")

gtdb_results_merged <- merge(gtdb_results, meta, by.x = "user_genome", by.y = "G_ID")

gtdb_results_merged <- gtdb_results_merged %>% 
  mutate(gtdb_species_classification = classification)

# Remove all before and up to ";s_"
gtdb_results_merged$gtdb_species_classification <- gsub(".*;s__","",gtdb_results_merged$gtdb_species_classification)

# reorder columns
gtdb_results_merged <- gtdb_results_merged %>%
  select(user_genome,pangenome_ID,classification,gtdb_species_classification,classification_method, fastani_reference,fastani_reference_radius,fastani_taxonomy, fastani_ani,fastani_af, note, other_related_references.genome_id.species_name.radius.ANI.AF.)

# write results
write.table(gtdb_results_merged, "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/29_GTDBTK/classify_out/gtdbtk.bac120.merged_results.txt", quote = FALSE, row.names = FALSE, sep = "\t")
```


```{bash, eval=FALSE}

# send results to local
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/29_GTDBTK/classify_out/gtdbtk.bac120.merged_results.txt /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/29_GTDBTK/gtdbtk.bac120.merged_results.txt

```


###### 2.17.2 G_0636 classification

```{bash, eval=FALSE}


conda deactivate # ignore it if it complains
module purge
module load miniconda/3
source /bioware/miniconda3/bashrc 
conda activate /bioware/gtdbtk-2.3.0
gtdbtk check_install

module load clusters/barhal
module load jbpc


# Create the directory.

mkdir 29_GTDBTK/G_0636
mkdir 29_GTDBTK/G_0636/Genomes
mkdir 29_GTDBTK/G_0636/classify_out 
mkdir 29_GTDBTK/G_0636/tmp


projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab

cd $mainDIR/$projectID

# make custom_taxonomy_file for gtdbtk decorate
cat DATA/$projectID-G_0636-add_info.items.txt | awk -F"\t" 'NR>1 {print $9, $2}' > 29_GTDBTK/G_0636/custom_taxonomy_file.txt


G_0636_name_conv=DATA/G_0636-name_conversions.txt
# move genomes to 29_GTDBTK/Genomes directory (moved to qrsh screen session to run this code)
for G_ID in `cat $G_0636_name_conv | awk '{print $2}'`; do
cp 03_GENOMES_EDITED/${G_ID}.fa 29_GTDBTK/G_0636/Genomes/${G_ID}.fa
done

# run script
# Added --mash_db gtdb-tk-r214.msh 
#chmod +x CRIPTS/script-gtdbtk-classify_wf_G_0636.sh

/workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/script-gtdbtk-classify_wf_G_0636.sh > LOGS/gtdbtk-classify_wf_G_0636.log 2>&1 &


```

```{r}
library(dplyr)
gtdb_results <- read.table("/workspace/jmarkwelchlab/P_0003_Neisseriaceae/29_GTDBTK/G_0636/classify_out/gtdbtk.bac120.summary.tsv", header = TRUE, sep = "\t")

meta <- read.table("/workspace/jmarkwelchlab/P_0003_Neisseriaceae/DATA/G_0636-name_conversions.txt", header = FALSE)
colnames(meta) <- c("pangenome_ID", "G_ID")

gtdb_results_merged <- merge(gtdb_results, meta, by.x = "user_genome", by.y = "G_ID")

gtdb_results_merged <- gtdb_results_merged %>% 
  mutate(gtdb_species_classification = classification)

# Remove all before and up to ";s_"
gtdb_results_merged$gtdb_species_classification <- gsub(".*;s__","",gtdb_results_merged$gtdb_species_classification)

# reorder columns
gtdb_results_merged <- gtdb_results_merged %>%
  select(user_genome,pangenome_ID,classification,gtdb_species_classification,classification_method, fastani_reference,fastani_reference_radius,fastani_taxonomy, fastani_ani,fastani_af, note, other_related_references.genome_id.species_name.radius.ANI.AF.)

# write results
write.table(gtdb_results_merged, "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/29_GTDBTK/G_0636/classify_out/gtdbtk.bac120.merged_results.txt", quote = FALSE, row.names = FALSE, sep = "\t")
```


```{bash, eval=FALSE}

# send results to local
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/29_GTDBTK/G_0636/classify_out/gtdbtk.bac120.merged_results.txt /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/29_GTDBTK/G_0636/gtdbtk.bac120.merged_results.txt

```


# 3. Dereplication

##### 3.1 G_0636

```{bash}

mainDIR=/workspace/jmarkwelchlab
projectID=P_0003_Neisseriaceae
DIR_Derep=$mainDIR/$projectID/15_DE_REPLICATION
DIR_ANI=$mainDIR/$projectID/09_PANGENOME/P_0003_Neisseriaceae_G_0636-pangenome/P_0003_Neisseriaceae_G_0636-pangenome-RESULTS/ANI_RESULTS

anvi-dereplicate-genomes -o $DIR_Derep/G_0636/G_0636_ANI_98_dereplication_fastANI --ani-dir $DIR_ANI --skip-fasta-report --program fastANI --similarity-threshold 0.98 --cluster-method simple_greedy --representative-method centrality --num-threads 20 --log-file $mainDIR/$projectID/LOGS/G_0636_ANI_98_dereplication_fastANI.log


#Check
cat $DIR_Derep/G_0636/G_0636_ANI_98_dereplication_fastANI/CLUSTER_REPORT.txt | wc -l


# send to local

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/15_DE_REPLICATION/G_0636/G_0636_ANI_98_dereplication_fastANI/CLUSTER_REPORT.txt /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/15_DE_REPLICATION/G_0636/CLUSTER_REPORT.txt

```

Beyond dereplication at 98% ANI, the follwoing criteria were also applied:

Remove 3 sp. genomes that associate with non-human-associated taxa.
2 with N. musculi
1 with N. zoodegmatis

Keep 3 N. sp. MVDL genomes that clustered in phylogeny next to N. anamolaris, but were distinct group based on ANI.

Remove the 3 N. macacae genomes and keep the 1 misidentified in NCBI as N. mucosa.

Remove 4 N. dentiae genomes and keep the 1 isolated from humans.

Remove N. zalophi  genome that is likely N. cinerea.

Keep the 2 N. perflava genomes that cluster in phylogeny far away from other N. perflava genomes because they are unique (share less than 90% ANI with all other genomes).

Keep both distinct K. sp. and N. sp. groups (2 genomes each).

Keep the K. potus genome that was isolated from humans - although likely an animal associated taxa. Thi sspecies was reported at very low rel abundance levels by metaphlan.Likely that the actual bacteria present is N. baccilliformis


##### 3.2 Plot distribution of selected reference genomes for mapping

```{r, eval=FALSE}

library(dplyr)
G_0213_derep_sel <- read.csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/DATA/Neisseriaceae_metapangenomics_mapping_reference_genomes.csv", header = TRUE)


G_0213_derep_sel_summary <- G_0213_derep_sel %>% 
  group_by(Genus,Reclassified_Species) %>% 
  summarise(n = n())


G_0213_derep_sel_summary <- as.data.frame(G_0213_derep_sel_summary)
G_0213_derep_sel_summary$Genus <- as.factor(G_0213_derep_sel_summary$Genus)
G_0213_derep_sel_summary$Reclassified_Species <- as.factor(G_0213_derep_sel_summary$Reclassified_Species)

dodge <- position_dodge(width=0.9)

G_0213_derep_sel_summary$Genus <- factor(G_0213_derep_sel_summary$Genus, levels = c("Neisseria", "Kingella", "Eikenella", "Simonsiella"), ordered = TRUE)


plot <- ggplot(G_0213_derep_sel_summary, aes(x = reorder(Reclassified_Species, -n), y = n, fill = Genus)) +
  geom_bar(stat = 'identity',position = dodge, color = "black") +
  geom_text(aes(label = n), vjust = -.5) +
  facet_grid(. ~ Genus, scales = "free", space = "free") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 45)) +
  xlab(NULL)+
  ylab("Frequency") +
  theme_classic() +
  theme(text = element_text(size = 12, color = "black"),
        strip.text.x = element_blank(),
        axis.text.x = element_text(angle = 45,vjust = 1, hjust=1, face = "italic", color = "black")) 

# clean up plot slightly
plot <- plot +
  theme(
    panel.background = element_rect(fill = "white"), 
    panel.grid = element_blank(),
    axis.line = element_blank()
  )



ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/FIGURES/Plots/Renamed_genomes_G_0213_dereplicated_selected.pdf", plot, height = 6, width = 11)




G_0213_derep_sel_summary <- G_0213_derep_sel %>% 
  group_by(Genus,Species) %>% 
  summarise(n = n())


G_0213_derep_sel_summary <- as.data.frame(G_0213_derep_sel_summary)
G_0213_derep_sel_summary$Genus <- as.factor(G_0213_derep_sel_summary$Genus)
G_0213_derep_sel_summary$pecies <- as.factor(G_0213_derep_sel_summary$Species)

dodge <- position_dodge(width=0.9)

G_0213_derep_sel_summary$Genus <- factor(G_0213_derep_sel_summary$Genus, levels = c("Neisseria", "Kingella", "Eikenella", "Simonsiella"), ordered = TRUE)


plot <- ggplot(G_0213_derep_sel_summary, aes(x = reorder(Species, -n), y = n, fill = Genus)) +
  geom_bar(stat = 'identity',position = dodge, color = "black") +
  geom_text(aes(label = n), vjust = -.5) +
  facet_grid(. ~ Genus, scales = "free", space = "free") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 45)) +
  xlab(NULL)+
  ylab("Frequency") +
  theme_classic() +
  theme(text = element_text(size = 12, color = "black"),
        strip.text.x = element_blank(),
        axis.text.x = element_text(angle = 45,vjust = 1, hjust=1, face = "italic", color = "black")) 

# clean up plot slightly
plot <- plot +
  theme(
    panel.background = element_rect(fill = "white"), 
    panel.grid = element_blank(),
    axis.line = element_blank()
  )



ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/FIGURES/Plots/NCBI_names_G_0213_dereplicated_selected.pdf", plot, height = 6, width = 11)
```


##### 3.3. Update reference genome metadata files

Send mapping reference genome metadata to Barhal
```{bash, eval=FALSE}

scp -r /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/DATA/Neisseriaceae_metapangenomics_mapping_reference_genomes.csv jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/DATA/Neisseriaceae_metapangenomics_mapping_reference_genomes.csv
```

```{bash, eval=FALSE}

# Update contigs path file
GENOMES_G_0636=$mainDIR/$projectID/DATA/$projectID-G_0636-contig_paths.txt
GENOMES_G_0213=$mainDIR/$projectID/DATA/$projectID-G_0213-contig_paths.txt
mapping_ref_genome_metadata=$mainDIR/$projectID/DATA/Neisseriaceae_metapangenomics_mapping_reference_genomes.csv
mapping_ref_genomes=$mainDIR/$projectID/DATA/Pangenome_IDs_Neisseriaceae_metapangenomics_mapping_reference_genomes.txt

awk -F"," 'NR>1{print $1}' "$mapping_ref_genome_metadata" > "$mapping_ref_genomes"
grep -Ff "$mapping_ref_genomes" "$GENOMES_G_0636" > "$GENOMES_G_0213"


# Update meta data file to add to pangenome
layersADD_G_0213=$mainDIR/$projectID/DATA/$projectID-G_0213-add_info.items.txt
ITEMS=$mainDIR/$projectID/DATA/$projectID-G_0636-add_info.items.txt
head -n1 $ITEMS > $layersADD_G_0213
for genomeTypeID in `cat $GENOMES_G_0213`
do
cat $ITEMS | grep "$genomeTypeID" >> $layersADD_G_0213
done


# update name conversions file
G_0636_name_conv=$mainDIR/$projectID/DATA/G_0636-name_conversions.txt
G_0213_name_conv=$mainDIR/$projectID/DATA/G_0213-name_conversions.txt
grep -Ff "$mapping_ref_genomes" "$G_0636_name_conv" > "$G_0213_name_conv"

# make genomes ID file
G_0213_genomesID=$mainDIR/$projectID/DATA/id_genomes-G_0213.txt
awk '{print $2}' $G_0213_name_conv > $G_0213_genomesID

```

# 4. Mapping


##### 4.1 Concatenate reference genomes for maopping 


```{bash, eval=FALSE Concatenate fasta for reference genome set for mapping }

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Assemblies=02_ASSEMBLIES
DIR_Contigs=03_GENOMES_EDITED
DIR_ContigsDB=04_CONTIGS_DB
G_0213_genomesID=$mainDIR/$projectID/DATA/id_genomes-G_0213.txt
RAW_ASSEMBLY=$DIR_Assemblies/${projectID}-RAW.fa
PROJECT_CONTIGS=$DIR_Contigs/${projectID}.fa
PROJECT_REPORT=$DIR_Contigs/${projectID}.report.tsv
BINNING=$DIR_Contigs/${projectID}.binning.tsv
DECOMPOSE=$DIR_Contigs/${projectID}.decompose.tsv
CONTIGS_DB=$DIR_ContigsDB/${projectID}-contigs.db
minContigSIZE=300
G_0213_name_conv=$mainDIR/$projectID/DATA/G_0213-name_conversions.txt


# make concatenated genome file for METAPANGENOME
for genome in `cat $G_0213_genomesID`
do
CONTIGS=$DIR_Contigs/${genome}.fa
cat $CONTIGS >> $RAW_ASSEMBLY
done

# Reformat concatenated-genomes using ANVIO (anvi-script-reformat-fasta)
anvi-script-reformat-fasta -l $minContigSIZE -o $PROJECT_CONTIGS --simplify-names --prefix ${projectID} -r $PROJECT_REPORT $RAW_ASSEMBLY
```


To produce the decomposition file, please see Modifying_decomposition_file.Rmd. Below is an exmaple, but does not represent the process used to generate the modified decomposition file used in the decompose and summarize script.

```{bash, eval=FALSE}

# Binning and decomposition files
cat $PROJECT_REPORT | awk -F'_' -v OFS="_" 'NF{--NF};1' > $BINNING

while IFS= read -r line
do
intGenomeID=$( echo "$line" | awk '{print $2}' )
newBinID=$( echo "$line" | awk '{print $1}' )
grep "$intGenomeID" $BINNING | sed -e "s/$intGenomeID/$newBinID/" >> $DECOMPOSE
done < $G_0213_name_conv


```

##### 4.2 Send list of metagenome sample info to remote server

```{bash, eval=FALSE}

scp -r /Users/home/SPECIES_LEVEL_PANGENOMES/HMP_metadata/Final_1297_HMP_metagenomes_metadata.csv jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/HMP_SAMPLE_DATA/Final_1297_HMP_metagenomes_metadata.csv

```

##### 4.3 Create symbolic links for HMP metagenomes. 

```{bash, eval=FALSE}

DIR_HMP_INFO=/workspace/jmarkwelchlab/HMP_SAMPLE_DATA
DIR_SITE=/storage3/data/02_QUALITY_FILTERED_HMP_SAMPLES
DIR_READS=/workspace/jmarkwelchlab/P_0003_Neisseriaceae/00_READS


for metagenome in `awk -F"," 'NR>1{print $3}' "$DIR_HMP_INFO/Final_1297_HMP_metagenomes_metadata.csv"`
do
    Internal_ID=$(awk -F"," -v meta="$metagenome" '$3 == meta {gsub(/"/, "", $1); print $1}' "$DIR_HMP_INFO/Final_1297_HMP_metagenomes_metadata.csv")
    
    metagenome_ID=$(awk -F"," -v meta="$metagenome" '$3 == meta {gsub(/"/, "", $3); print $3}' "$DIR_HMP_INFO/Final_1297_HMP_metagenomes_metadata.csv")
    
    ln -s "$DIR_SITE/${metagenome_ID}-QUALITY_PASSED_R1.fastq.gz" "$DIR_READS/${Internal_ID}_R1.fastq.gz"
    ln -s "$DIR_SITE/${metagenome_ID}-QUALITY_PASSED_R2.fastq.gz" "$DIR_READS/${Internal_ID}_R2.fastq.gz"
done


# check a link
ls -l /workspace/jmarkwelchlab/P_0003_Neisseriaceae/00_READS/PP_HC_HMP_S0054_01_R2.fastq.gz

```


Set up samples_id-QC_IDs.txt file, which is simply a header-less column containing sample IDs that match the prefixes of the _R1.fastq.gz and _R2.fastq.gz files. Make sure samples_id-QC_IDs.txt is in the main directory. 

```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_HMP_INFO=$mainDIR/HMP_SAMPLE_DATA

# copy samples_id-QC_IDs_686.txt to the samples_id-QC_IDs.txt file in the main directory for mapping
awk -F","  'NR>1 {gsub(/"/, "", $1); print $1}' "$DIR_HMP_INFO/Final_1297_HMP_metagenomes_metadata.csv" > $mainDIR/$projectID/samples_id-QC_IDs.txt

```

Directories that are needed to be cleared (i.e., move all stuff that is already in there from a previous into new directory named TEST_RUN05: 
05_MAPPING
06_SINGLE_PROFILE
07_MERGED_PROFILE
08_PROFILE_SUMMARY
13_DETECTED_GENOMES

copy scripts for MAPPING in parallel, profiling mapped reads, merging profiles my oral sites, and decomposing and summarizing merged profiles:

```{bash, eval=FALSE}
cp -r /workspace/jmarkwelchlab/P_0622_Haemophilus_Aggregatibacter/SCRIPTS  /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts

##### edit scripts
# Make sure min contig size 300
# Make sure internal script directories are ok (e.g., ...P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts...)

# Single profiles
nano /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-03-single_profiling_parallel.sh
/workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-single_profile.sh

# Merging profiles
nano /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-04-merged_profile_parallel.sh
/workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-merged_profile-HP.sh
 /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-merged_profile.sh
 
# decompose merged profile, estimate SCG taxonomy and summarize
nano /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-05-decompose_summarize_profile_parallel.sh
/workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-decompose_summarize_profile.sh

```


##### 4.4 Run the mapping script

```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae

clusterize -n 15 -m jgiacomini@forsyth.org -log LOGS/mapping.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-02-indexing_and_mapping_parallel.sh $projectID 

cat LOGS/mapping.log | grep "overall alignment rate" | wc -l

```


We should consider the output for each sample. In particular, the number of mates that map once versus more than once. For exmaple, for this sample, 4009 (0.12%) aligned exactly 1 time...

5210 (0.16%) aligned >1 times
1655580 reads; of these:
1655580 (100.00%) were paired; of these:
1635230 (98.77%) aligned concordantly 0 times
2163 (0.13%) aligned concordantly exactly 1 time
18187 (1.10%) aligned concordantly >1 times
1635230 pairs aligned concordantly 0 times; of these:
90 (0.01%) aligned discordantly 1 time
1635140 pairs aligned 0 times concordantly or discordantly; of these:
3270280 mates make up the pairs; of these:
3261061 (99.72%) aligned 0 times
4009 (0.12%) aligned exactly 1 time
5210 (0.16%) aligned >1 times
1.51% overall alignment rate


Should we be worried about the ratio of aligned exactly 1 time to aligned >1 times? If so, should we tweak. mapping sensitivity such that the ratio is reduced as much as possible? If the sensitivity parameter is continuous, we could find the asymptote where the ratio flattens out. This would require a significant multiple mapping pipeline, perhaps with smaller sample size. But we should be careful not to bias and only test samples with a lot of reads, or a lot of reads mapped. We need an idea of how the ratio changes for the range of sample sizes (number of reads) and the percent of reads that mapped (overall alignment rate). 

The problem is that we expect both the overall alignment rate and the number of reads that aligned >1 times to decrease, not necessarily linearly because the number of reads that aligned 0 times may also decrease in an unknown, non-mutually exclusive relationship. So it may be a waste of time to try and find a sweet spot where we maximize the overall alignment rate and minimize the number of reads that aligned >1 times. That said, we should really care about a the ratio between the change in overall alignment rate (baseline overall alignment rate - new overall alignment rate) divided by the (baseline aligned >1 times rate - new aligned >1 times rate). 

For example, if baseline overall alignment rate = 1.51 and baseline aligned >1 times rate = 0.16, and a known chnage in the mapping sensitivity lead to new overall alignment rate of 2.00 and a new aligned >1 times rate of 0.10, the effect size would be:

|(1.51 + 2.00)/(0.16 + 0.10)| = 13.5 # increase in both (OK)

|(1.51 + 1.45)/(0.16 + 0.18)| = 8.705882 # decrease in both (OK)

|(1.51 + 2)/(0.16 + 0.16)| = 10.96875 # increase in A only (GREAT)

|(1.51 + 1.51)/(0.16 + 0.5)| = 4.575758 # increase in B only (BAD)

|(1.51 + 1.51)/(0.16 + 0.08)| = 12.58333 # decrease in B only (GREAT)

|(1.51 + 1.51)/(0.16 + 0.08)| = 12.58333 # decrease in B only (GREAT)


We could start by selecting 10 TD samples with a lot of reads and seeing if it matters. Loop through a mapping script and vary it by the mapping parameter, extract the relevant data from log files, or maybe even the bam files, then generate the plots and look for an asymptote (if we're lucky!). 

Alternatively there are other mapping statistics that we could consider as better measures, instead of overall alignment rate or aligned >1 times. Here is an example of the read information that we get for a bam file:

SN      raw total sequences:    22160568
SN      filtered sequences:     0
SN      sequences:      22160568
SN      is sorted:      1
SN      1st fragments:  11080284
SN      last fragments: 11080284
SN      reads mapped:   22160568
SN      reads mapped and paired:        22160568        # paired-end technology bit set + both mates mapped
SN      reads unmapped: 0
SN      reads properly paired:  22160568        # proper-pair bit set
SN      reads paired:   22160568        # paired-end technology bit set
SN      reads duplicated:       0       # PCR or optical duplicate bit set
SN      reads MQ0:      60310   # mapped and MQ=0
SN      reads QC failed:        0
SN      non-primary alignments: 0
SN      total length:   2791389998      # ignores clipping
SN      total first fragment length:    1395694999      # ignores clipping
SN      total last fragment length:     1395694999      # ignores clipping
SN      bases mapped:   2791389998      # ignores clipping
SN      bases mapped (cigar):   2784413487      # more accurate
SN      bases trimmed:  0
SN      bases duplicated:       0
SN      mismatches:     14140177        # from NM fields
SN      error rate:     5.078332e-03    # mismatches / bases mapped (cigar)
SN      average length: 125
SN      average first fragment length:  126
SN      average last fragment length:   126
SN      maximum length: 126
SN      maximum first fragment length:  126
SN      maximum last fragment length:   126
SN      average quality:        37.0
SN      insert size average:    741.9
SN      insert size standard deviation: 1310.4
SN      inward oriented pairs:  11072258
SN      outward oriented pairs: 8026
SN      pairs with other orientation:   0
SN      pairs on different chromosomes: 0
SN      percentage of properly paired reads (%):        100.0


The error rate, which is the # mismatches / bases mapped (cigar), seems like an interesting metric to plot for each sample. 


* see for guide on definitions below: 
https://www.htslib.org/doc/samtools-stats.html#:~:text=The%20SN%20section%20contains%20a,excluding%20supplementary%20and%20secondary%20reads.


We should plot some of those mapping statistics onto our coverage, detection and rel abundance figures, alongside total reads, total reads mapped, etc. In fact, I would rather we use these bam stats results as our baseline, because the stats are comprehensive and samtools stats is a extremely commonly used program/function to extract mapping stats from mapping runs. I am particylarly intrested in:

raw total sequences - total number of reads in a file, excluding supplementary and secondary reads. Same number reported by samtools view -c -F 0x900.


bases mapped (cigar) - number of mapped bases filtered by the CIGAR string corresponding to the read they belong to. Only alignment matches(M), inserts(I), sequence matches(=) and sequence mismatches(X) are counted.

error rate - ratio between mismatches and bases mapped (cigar).
average quality - ratio between the sum of base qualities and total length.


Keep in mind that we used the flag -F 4 in proccessing the original sam file into a bam file, which means (0x4	UNMAP	segment unmapped) unmapped reads were removed. Thus the samtools stats data is only of the reads that mapped. None of those stats reflect the total number of reads in the sample. 


We can loop through our bam files usig the following code:

```{bash, eval=FALSE}

for sample in `cat $mainDIR/$projectID/samples_id-QC_IDs.txt`
do
samtools stats 05_MAPPING/$sample.bam | grep ^SN | cut -f 2- > 05_MAPPING/$sample-mapping-stats.txt
done

```

The following r script loops through each 05_MAPPING/$sample-mapping-stats.txt file, extracts the relevant data, transposes it, and then concatenates the individual data frames into one final data frame.

```{r, eval=FALSE}

# Load necessary libraries
library(dplyr)
library(tidyr)
library(readr)

# Set the directory
dir_mapping <- "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/05_MAPPING"

# List all files
file_list <- list.files(path = dir_mapping, pattern = "-mapping-stats.txt", full.names = TRUE)

# Initialize an empty data frame
final_df <- data.frame()

# Process each file
for (file in file_list) {
  # Extract sample name or identifier from the file name
  sample_name <- basename(file)
  sample_name <- gsub("-mapping-stats.txt", "", sample_name)

  # Read file content
  file_content <- read_lines(file)

  # Extract key-value pairs and remove comments
  key_value_pairs <- strsplit(file_content, ":")
  key_value_pairs <- lapply(key_value_pairs, function(x) {
    key <- trimws(x[1])
    value <- trimws(sub("#.*", "", x[2]))
    return(c(key, value))
  })

  # Convert to data frame
  df <- do.call(rbind, key_value_pairs)
  colnames(df) <- c("Metric", sample_name)
  df <- df %>% spread(Metric, sample_name)

  # Combine with the final data frame
  final_df <- bind_rows(final_df, df)
}

# View the final data frame
print(final_df)

# save the final data frame
write.table(final_df, "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/05_MAPPING/Concatenated_mapping_stats.txt", row.names = FALSE, quote = FALSE)

```

# 5. Concatenated Contig db, gene calling and hmms annotation

The following is a script for creating an Anvio contigs db (inlcuding gene calling and hmms annotation within anvio) for the concatenated reference genome set that we used for mapping. We need the single contigs db for the profiling steps; note that we have yet to annotate the contig db with gene functions, which we will do later. 

Note that running multiple Anvi'o processes that access and modify the same contigs database simultaneously can be risky, as concurrent writes or updates to the database may lead to corruption or data inconsistencies. This is especially true if one of the processes is modifying the database structure or adding new data to it, as is the case with anvi-run-ncbi-cogs. The anvi-run-ncbi-cogs function, as part of its operation, updates the contigs database with COG (Clusters of Orthologous Groups) functional annotations. This process involves writing new information to the database. On the other hand, anvi-profile generates profile databases from BAM files using a contigs database, and it might also access the database for read retrieval and other operations.

To avoid potential conflicts or database corruption, it's generally safer not to run these two commands simultaneously on the same contigs database. Here are a few suggestions:



```{bash}
# script for contigsdb, gene calling and hmms annotation (within anvio); need the single contigs db for the profiling steps; note that we have yet to annotate the contig db with gene functions. since this is just the first mapping run. 

projectID=P_0003_Neisseriaceae

clusterize -n 10 -m jgiacomini@forsyth.org -log LOGS/Concatenated_contigdb.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-01-contigsDB_annotation_hmms.sh $projectID 
```

 Note that anvi-run-scg-taxonomy encountered an error and failed... Not a problem at all. Just ignore. 

# 6. Profiling mapped reads 

##### 6.1 Run single profile script

```{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae

clusterize -n 15 -m jgiacomini@forsyth.org -log LOGS/profiling.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-03-single_profiling_parallel.sh $projectID
```


```{bash, eval=FALSE}
cat LOGS/profiling.log | grep "Happy" | wc -l
```

1297 samples and only 1283 occurrences of "Happy" for single profiling, indicating that 14 samples possibly failed. Also, running the merge profile script resulted in the following errors for some oral sites:

Config Error: The database '06_SINGLE_PROFILE/BM_HC_HMP_S0034_02/PROFILE.db' has no 'db_type'
              row in 'self'

Config Error: There is something wrong with your input databases. The group name 'default'
              should be common to all of them, but it doesn't seem to be the case :/ How did
              you end up with an anvi'o single profile database that doesn't have the
              'default' group in its additional layer data table? It is very likely that your
              profiling step failed for some reason for one or more of your databases :(
              

Unfortunately, Anvio did not tell me which single profile database caused the error/s. Fortunately there is a runlog asscocaiated with each sample in the profiling step. The following code will parse the information from each single profile run log. It will print the sample name and then whether or not the profile completed,  "happy", or did not "misisng". If the runlog is missing it will also print the sample name and the string "missing". 

```{bash, eval=FALSE}

for sample in `cat samples_id-QC_IDs.txt`
do
    # Print the sample name
    echo -n "$sample " >> Single_profile_runlog_Happy_test.txt
    
    # Check for the string "Happy" in the RUNLOG.txt
    if grep -q "Happy" 06_SINGLE_PROFILE/"$sample"/RUNLOG.txt; then
        # If "Happy" is found, print the line containing "Happy"
        echo "happy" >> Single_profile_runlog_Happy_test.txt
    else
        # If "Happy" is not found, print "missing"
        echo "missing" >> Single_profile_runlog_Happy_test.txt
    fi
done

cat Single_profile_runlog_Happy_test.txt | grep "missing" | wc -l 

```
        

Re-run single profiles for the 14 samples identified above:

```{bash, eval=FALSE}

# make list of missing samples
cat Single_profile_runlog_Happy_test.txt | grep "missing" | awk '{print $1}' > missing_samples_id-QC_IDs.txt

# move old single profiles to temp diretcory
mkdir FAILED_SINGLE_PROFILES
for sample in `cat  missing_samples_id-QC_IDs.txt`
do
mv 06_SINGLE_PROFILE/$sample FAILED_SINGLE_PROFILES/$sample
done

# Two samples missing entirely from 06_SINGLE_PROFILE directory:
# mv: cannot stat '06_SINGLE_PROFILE/PP_HC_HMP_S0135_02': No such file or directory
# mv: cannot stat '06_SINGLE_PROFILE/TD_HC_HMP_S0116_01': No such file or directory


# run the following script to profile the 14 missing samples
projectID=P_0003_Neisseriaceae

clusterize -n 15 -m jgiacomini@forsyth.org -log LOGS/missing_samples_profiling.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-03-single_profiling_parallel_missing_samples.sh $projectID
```

Check the new profiles:

```{bash}

for sample in `cat missing_samples_id-QC_IDs.txt`
do
    # Print the sample name
    echo -n "$sample " >> Missing_single_profile_runlog_Happy_test.txt
    
    # Check for the string "Happy" in the RUNLOG.txt
    if grep -q "Happy" 06_SINGLE_PROFILE/"$sample"/RUNLOG.txt; then
        # If "Happy" is found, print the line containing "Happy"
        echo "happy" >> Missing_single_profile_runlog_Happy_test.txt
    else
        # If "Happy" is not found, print "missing"
        echo "missing" >> Missing_single_profile_runlog_Happy_test.txt
    fi
done

cat Missing_single_profile_runlog_Happy_test.txt | grep "happy" | wc -l # 14
cat Missing_single_profile_runlog_Happy_test.txt | grep "missing" | wc -l # 0
```

All showed "happy"... success!!!
Also, we now see 1297 single profiles in the 06_SINGLE_PROFILE/ directory, yay! At least in terms of their run logs. That is not a guarantee that the data bases are ok though...foreshadowing...


##### 6.2 Merge profiles by oral site

Need to amend the merge profile for single site HP. I just manually copied the HP single profile directory into the merged profile directory.  

Note that I added the flags --overwrite-output-destinations & --skip-hierarchical-clustering 
````{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae

mkdir 07_MERGED_PROFILE/${projectID}_HP 
cp 06_SINGLE_PROFILE/HP_HC_HMP_S0195_01/* 07_MERGED_PROFILE/${projectID}_HP/

clusterize -n 15 -m jgiacomini@forsyth.org -log LOGS/merge_profiles.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-04-merged_profile_parallel.sh $projectID  
```

Check the run logs for each merged profile. We want to see a "Happy" next to each oral site:

```{bash}
for site in TD BM HP KG PB PP PT SA TH; do

  status=$(cat 07_MERGED_PROFILE/P_0003_Neisseriaceae_${site}/RUNLOG.txt | grep -o "Happy")
  echo -e "$site\t$status"
  
done
```

There were many errors and I had to run anvi-merge script numerous times. Below are some of the errors that I found running the following code:

```{bash, eval=FALSE}

cat LOGS/merge_profiles.log| grep -A 5 "Config Error:"

```


Config Error: /automounts/workspace/workspace/jmarkwelchlab/P_0003_Neisseriaceae/07_MERGED_PRO
              FILE/P_0003_Neisseriaceae_PT/PROFILE.db does not seem to be a database generated
              by anvi'o :/
              
Config Error: Someone downstream doesn't like your so called database,
              '06_SINGLE_PROFILE/PB_HC_HMP_S0209_01/PROFILE.db'. They say "database disk image
              is malformed". Awkward :(
              
Config Error: Someone downstream doesn't like your so called database,
              '06_SINGLE_PROFILE/PP_HC_HMP_S0182_04/PROFILE.db'. They say "database disk image
              is malformed". Awkward :(
              
Config Error: 06_SINGLE_PROFILE/TD_HC_HMP_S0058_03/PROFILE.db does not seem to be a database
              generated by anvi'o :/
              
Config Error: 06_SINGLE_PROFILE/BM_HC_HMP_S0172_02/PROFILE.db does not seem to be a database
              generated by anvi'o :/
              

Config Error: Someone downstream doesn't like your so called database,
              '06_SINGLE_PROFILE/PP_HC_HMP_S0207_02/PROFILE.db'. They say "database disk image
              is malformed". Awkward :(  
              
Config Error: Someone downstream doesn't like your so called database,
              '06_SINGLE_PROFILE/BM_HC_HMP_S0071_01/PROFILE.db'.              
              
              
For the above samples I re-built the single profile databases:

```{bash, eval=FALSE}

# run single profile
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab/$projectID
minContigSIZE=300
DIR_ContigsDB=$mainDIR/04_CONTIGS_DB
DIR_Mapping=$mainDIR/05_MAPPING
DIR_SinglePROF=$mainDIR/06_SINGLE_PROFILE
CONTIGS_DB=$DIR_ContigsDB/${projectID}-contigs.db

anvi-profile -i $DIR_Mapping/PB_HC_HMP_S0209_01.bam -c $CONTIGS_DB -o $DIR_SinglePROF/PB_HC_HMP_S0209_01 -S PB_HC_HMP_S0209_01 --min-contig-length $minContigSIZE --profile-SCVs --num-threads 5 --write-buffer-size-per-thread 30000 --force-overwrite

anvi-profile -i $DIR_Mapping/TD_HC_HMP_S0058_03.bam -c $CONTIGS_DB -o $DIR_SinglePROF/TD_HC_HMP_S0058_03 -S TD_HC_HMP_S0058_03 --min-contig-length $minContigSIZE --profile-SCVs --num-threads 5 --write-buffer-size-per-thread 30000 --force-overwrite

anvi-profile -i $DIR_Mapping/PP_HC_HMP_S0182_04.bam -c $CONTIGS_DB -o $DIR_SinglePROF/PP_HC_HMP_S0182_04 -S PP_HC_HMP_S0182_04 --min-contig-length $minContigSIZE --profile-SCVs --num-threads 5 --write-buffer-size-per-thread 30000 --force-overwrite

anvi-profile -i $DIR_Mapping/BM_HC_HMP_S0172_02.bam -c $CONTIGS_DB -o $DIR_SinglePROF/BM_HC_HMP_S0172_02 -S BM_HC_HMP_S0172_02 
--min-contig-length $minContigSIZE --profile-SCVs --num-threads 5 --write-buffer-size-per-thread 30000 --force-overwrite

anvi-profile -i $DIR_Mapping/PP_HC_HMP_S0207_02.bam -c $CONTIGS_DB -o $DIR_SinglePROF/PP_HC_HMP_S0207_02 -S PP_HC_HMP_S0207_02 --min-contig-length $minContigSIZE --profile-SCVs --num-threads 5 --write-buffer-size-per-thread 30000 --force-overwrite

anvi-profile -i $DIR_Mapping/BM_HC_HMP_S0071_01.bam -c $CONTIGS_DB -o $DIR_SinglePROF/BM_HC_HMP_S0071_01 -S BM_HC_HMP_S0071_01 --min-contig-length $minContigSIZE --profile-SCVs --num-threads 5 --write-buffer-size-per-thread 30000 --force-overwrite

```
              
I then re-ran the anvi-merge script above. All of the sites merged properly except for the BM site. So I deleted the merged profile database and ran the anvi-merge program again using the code below:     
              
````{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae
site=BM
mainDIR=/workspace/jmarkwelchlab/$projectID
DIR_ContigsDB=$mainDIR/04_CONTIGS_DB
DIR_SinglePROF=$mainDIR/06_SINGLE_PROFILE
DIR_MergedPROF=$mainDIR/07_MERGED_PROFILE
CONTIGS_DB=$DIR_ContigsDB/${projectID}-contigs.db

# Sample name
SAMPLE_NAME=${projectID}_${site}

# Merged profile directory
MERGED_PROFILE=$DIR_MergedPROF/$SAMPLE_NAME

# Single profiles per site
SINGLE_PROFILES_DB=$DIR_SinglePROF/${site}_*/PROFILE.db

# merged profiling per sample
anvi-merge -c $CONTIGS_DB --overwrite-output-destinations --skip-hierarchical-clustering -o $MERGED_PROFILE -S $SAMPLE_NAME $SINGLE_PROFILES_DB
```


For some unknown reason, when it is nearly complete I get the following error: Config Error: /Working_directory/PROFILE.db does not seem to be a database generated by anvi'o :/

Note that I the actual directory of the PROFILE.db is different and I changed it here for privacy reasons. The last line above the error statement reads:

[22 Nov 23 17:10:53 Views] Writing 'variability' of 'contigs' in 'BM_HC_HMP_S0129_01'

As far as I can tell, all of the single profile databases are fine. When I use sqlite3 to browse the PROFILE.db, everything seems fine. The list of tables. in the db is:

abundance_contigs
collections_bins_info
collections_info
collections_of_contigs
collections_of_splits
detection_contigs
indels
item_additional_data
item_orders
layer_additional_data
layer_orders
mean_coverage_Q2Q3_contigs
mean_coverage_contigs
self
states
std_coverage_contigs
variability_contigs
variable_codons
variable_nucleotides
views


When I query to count the number of rows in the detection_contigs, mean_coverage_contigs,  and mean_coverage_Q2Q3_contigs tables, there is 11115090 rows, whereas there are only 5910405 rows in the variability_contigs table. Does this indicate that the anvi-merge program suddenly stopped writing to the PROFILE.DB while working on the variability_contigs data?  This is a very large database with 13230 contigs and 29405 splits, so maybe there is a limit that was reached? Although, I successfully completed anvi-merge with several other single profile data sets that are just as large, if not larger, so I am skeptical that there is some DB size limit that I reached. 

```{bash, eval=FALSE}

# Open sqlite3 query of the BM PROFILE.db
sqlite3 07_MERGED_PROFILE/P_0003_Neisseriaceae_BM/PROFILE.db

# Check the self description table
SELECT * FROM "self";

# Check the detection data table
SELECT * FROM detection_contigs LIMIT 100;


# Chekc the number of rows for detection and mean coverage tables
SELECT COUNT(*) FROM detection_contigs;
SELECT COUNT(*) FROM mean_coverage_Q2Q3_contigs;
SELECT COUNT(*) FROM mean_coverage_contigs;

# quit sqlite3
.quit

```

After seeing that the detection and mean coverage tables seem intact and complete, I decided to move forward with the summarizing scripts below. 

##### 6.3 Summarize merged prfiles

The following script imports a collection to each oral site profile database that assigns a genome ID to the splits. It then summarizes the coverages for that collection, giving us coverages for each genome for each sample. 

```{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae

clusterize -n 20 -m jgiacomini@forsyth.org -log LOGS/decompose_summarize_2.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-05-decompose_summarize_profile_parallel.sh $projectID  

```

Unfortunately I learned the hard way that anvi-summarize causes Barhal to crash when running the summarize_profile_parallel script. anvi-summarize uses a significant amount of memory. And so, we are still missing  summaries for two oral sites - TD and PP. See section "6.5 Check summaries" where I counted the number of rows and columns of the files that we need, which showed that all sites except for TD and PP were complete.  

In additon to running anvi-summarize, we also ran anvi-import-collection for each merged profile. The following command shows that both the TD and PP merged profile databases contain the required Genome collection and so we do not need to import the genome collection again.

```{bash, eval=FALSE}

anvi-show-collections-and-bins -p 07_MERGED_PROFILE/P_0003_Neisseriaceae_TD/PROFILE.db
anvi-show-collections-and-bins -p 07_MERGED_PROFILE/P_0003_Neisseriaceae_PP/PROFILE.db

```


The following scripts will run anvi-summarize for TD and PP, seperately. 

```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
clusterize -n 10 -m jgiacomini@forsyth.org -log LOGS/decompose_summarize_TD.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-05-decompose_summarize_profile_NON_parallel.sh $projectID TD

projectID=P_0003_Neisseriaceae
clusterize -n 20 -m jgiacomini@forsyth.org -log LOGS/decompose_summarize_PP.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-05-decompose_summarize_profile_NON_parallel.sh $projectID PP


```



##### 6.4 Fix BM profile

Config Error: The database at 07_MERGED_PROFILE/P_0003_Neisseriaceae_BM/PROFILE.db does not
              seem to have a table named `mean_coverage_Q2Q3_splits` :/ Here is a list of
              table names this database knows: self, item_additional_data, item_orders,
              layer_additional_data, layer_orders, variable_nucleotides, variable_codons,
              indels, views, collections_info, collections_bins_info, collections_of_contigs,
              collections_of_splits, states, std_coverage_contigs, mean_coverage_contigs,
              mean_coverage_Q2Q3_contigs, detection_contigs, abundance_contigs,
              variability_contigs

Contig/split name conversion .................: 11692 contig names converted into 26845 split names.
Item names in input ..........................: 26,845
Num bins in input ............................: 192

```{bash, eval=FALSE}

# Open sqlite3 query of the BM PROFILE.db
sqlite3 07_MERGED_PROFILE/P_0003_Neisseriaceae_TD/PROFILE.db

# Check the detection data table
SELECT * FROM mean_coverage_Q2Q3_splits LIMIT 100;

# quit sqlite3
.quit

```


Re-attempt at merging the BM profile, but this time in a QRSH session with 20 slots (i.e. tons of working memory):

```{bash, eval=FALSE}

screen -S qrsh_sesh_2
qrsh -pe allslots 20

module load anvio
module load clusters/barhal
module load jbpc

projectID=P_0003_Neisseriaceae
site=BM
mainDIR=/workspace/jmarkwelchlab/$projectID
DIR_ContigsDB=$mainDIR/04_CONTIGS_DB
DIR_SinglePROF=$mainDIR/06_SINGLE_PROFILE
DIR_MergedPROF=$mainDIR/07_MERGED_PROFILE
CONTIGS_DB=$DIR_ContigsDB/${projectID}-contigs.db

# Sample name
SAMPLE_NAME=${projectID}_${site}_redo

# Merged profile directory
MERGED_PROFILE=$DIR_MergedPROF/$SAMPLE_NAME

# Single profiles per site
SINGLE_PROFILES_DB=$DIR_SinglePROF/${site}_*/PROFILE.db

# merged profiling per sample
anvi-merge -c $CONTIGS_DB --overwrite-output-destinations --skip-hierarchical-clustering -o $MERGED_PROFILE -S $SAMPLE_NAME $SINGLE_PROFILES_DB


#SUCCESSS!!!!

mv 07_MERGED_PROFILE/P_0003_Neisseriaceae_BM_redo 07_MERGED_PROFILE/P_0003_Neisseriaceae_BM
```


##### 6.5 Check summaries

```{bash, eval=FALSE}

declare -a siteArray=("BM" "TD" "PP" "PT" "TH" "KG" "PB" "SA" "HP")

for site in ${siteArray[@]}
do
    echo -e "$site"
    cat "08_PROFILE_SUMMARY/P_0003_Neisseriaceae_${site}-profile/bins_summary.txt" | wc -l
done



for site in ${siteArray[@]}
do
    echo -e "site\tdetection\tmean_coverage\tmean_coverage_Q2Q3"
    
   detection=$(awk -F'\t' '{print NF; exit}' "08_PROFILE_SUMMARY/P_0003_Neisseriaceae_${site}-profile/bins_across_samples/detection.txt")
   
    mean_coverage=$(awk -F'\t' '{print NF; exit}' "08_PROFILE_SUMMARY/P_0003_Neisseriaceae_${site}-profile/bins_across_samples/mean_coverage.txt")
    
    mean_coverage_Q2Q3=$(awk -F'\t' '{print NF; exit}' "08_PROFILE_SUMMARY/P_0003_Neisseriaceae_${site}-profile/bins_across_samples/mean_coverage_Q2Q3.txt")
    
    echo -e "$site\t$detection\t$mean_coverage\t$mean_coverage_Q2Q3"
done


# Number of rows for each should be 214
for site in ${siteArray[@]}
do
    echo -e "site\tdetection\tmean_coverage\tmean_coverage_Q2Q3"
    
   detection=$(cat "08_PROFILE_SUMMARY/P_0003_Neisseriaceae_${site}-profile/bins_across_samples/detection.txt" | wc -l)
   
    mean_coverage=$(cat "08_PROFILE_SUMMARY/P_0003_Neisseriaceae_${site}-profile/bins_across_samples/mean_coverage.txt" | wc -l)
    
    mean_coverage_Q2Q3=$(cat "08_PROFILE_SUMMARY/P_0003_Neisseriaceae_${site}-profile/bins_across_samples/mean_coverage_Q2Q3.txt" | wc -l)
    
    echo -e "$site\t$detection\t$mean_coverage\t$mean_coverage_Q2Q3"
done

```


# 7. Mean depth and breadth of coverage data

Concatenate mean coverage (depth) and detection (breadth) for all oral sites
```{bash, eval=FALSE}

# set up variables
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_DetectionGENOMES=$mainDIR/$projectID/13_DETECTED_GENOMES
DIR_SummaryPROF=$mainDIR/$projectID/08_PROFILE_SUMMARY

# Run for loop to extract and transpose data frames
for data in detection mean_coverage mean_coverage_Q2Q3
do
#variables
ref_site=SA
detTableTrans=$DIR_DetectionGENOMES/${projectID}-${data}.transposed.txt
detTableTransHeadless=$DIR_DetectionGENOMES/${projectID}-${data}.transposed.noheader.txt
detTSV=$DIR_DetectionGENOMES/${projectID}-${data}.txt
# transpose detection-tables to combine values from 9 oral sites
for site in PP PB BM KG TD PT TH HP SA 
do
projSite=${projectID}_${site}
siteDetTSV=$DIR_SummaryPROF/${projSite}-profile/bins_across_samples/${data}.txt
siteDetTSVtrans=$DIR_DetectionGENOMES/${projSite}-${data}.transposed.txt
anvi-script-transpose-matrix -o $siteDetTSVtrans $siteDetTSV
awk 'BEGIN{FS=OFS="\t"}NR>1{print $0}' $siteDetTSVtrans >> $detTableTransHeadless
done
# add header to detection-table (I choose ${ref_site}), transpose table, remove intermediate files
awk 'BEGIN{FS=OFS="\t"}NR==1{print $0}' $DIR_DetectionGENOMES/${projectID}_${ref_site}-${data}.transposed.txt > $detTableTrans
cat $detTableTransHeadless >> $detTableTrans
rm $DIR_DetectionGENOMES/${projectID}_*-${data}*txt $DIR_DetectionGENOMES/${projectID}-${data}*noheader*
anvi-script-transpose-matrix -o $detTSV $detTableTrans
rm $detTableTrans
done

```


Check the data - count the number of columns

P_0003_Neisseriaceae-detection.txt  P_0003_Neisseriaceae-mean_coverage_Q2Q3.txt  P_0003_Neisseriaceae-mean_coverage.txt

```{bash, eval=FALSE}


detection=$(awk -F'\t' '{print NF; exit}' "13_DETECTED_GENOMES/P_0003_Neisseriaceae-detection.txt")
mean_coverage=$(awk -F'\t' '{print NF; exit}' "13_DETECTED_GENOMES/P_0003_Neisseriaceae-mean_coverage.txt")
mean_coverage_Q2Q3=$(awk -F'\t' '{print NF; exit}' "13_DETECTED_GENOMES/P_0003_Neisseriaceae-mean_coverage_Q2Q3.txt")
    
echo -e "detection\tmean_coverage\tmean_coverage_Q2Q3"
echo -e "$detection\t$mean_coverage\t$mean_coverage_Q2Q3"

```

##### 7.1 Export total reads mapped data

Anvio reports mapping stats for  each sample, including the number of SNVs, SCVs, and indels. We can loop through each oral site profile and extract the info. However, we need to fix an issue where each oral site data frame has a different header order. The following R script will loop through the input files for the oral sites (BM TD PP PT PB TH KG SA HP), reorder columns so that they match. 

```{r, eval=FALSE}

# First need to arrange each data frame into the same order of columns
library(dplyr)

# Define the desired column order
new_cols <- c("layers", "total_reads_mapped", "total_reads_kept", "num_SNVs_reported", "num_SCVs_reported", "num_INDELs_reported")

# Loop through the input files and reorder columns BM TD PP PT PB TH KG SA HP 
for (file_name in c("/workspace/jmarkwelchlab/P_0003_Neisseriaceae/08_PROFILE_SUMMARY/P_0003_Neisseriaceae_TD-profile/misc_data_layers/default.txt",
                    "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/08_PROFILE_SUMMARY/P_0003_Neisseriaceae_BM-profile/misc_data_layers/default.txt",
                    "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/08_PROFILE_SUMMARY/P_0003_Neisseriaceae_PP-profile/misc_data_layers/default.txt",
                    "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/08_PROFILE_SUMMARY/P_0003_Neisseriaceae_PT-profile/misc_data_layers/default.txt",
                    "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/08_PROFILE_SUMMARY/P_0003_Neisseriaceae_PB-profile/misc_data_layers/default.txt",
                    "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/08_PROFILE_SUMMARY/P_0003_Neisseriaceae_TH-profile/misc_data_layers/default.txt",
                    "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/08_PROFILE_SUMMARY/P_0003_Neisseriaceae_KG-profile/misc_data_layers/default.txt",
                    "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/08_PROFILE_SUMMARY/P_0003_Neisseriaceae_SA-profile/misc_data_layers/default.txt",
                    "/workspace/jmarkwelchlab/P_0003_Neisseriaceae/08_PROFILE_SUMMARY/P_0003_Neisseriaceae_HP-profile/misc_data_layers/default.txt"
                    )) {
  # Read in the data
  df <- read.delim(file_name, header = TRUE, stringsAsFactors = FALSE, sep = "\t")
  
  # Reorder the columns based on the desired order
  df <- df[, new_cols]
  
  # Write out the updated data to a new file
  write.table(df, file = paste0(file_name, "_new.txt"), sep = "\t", row.names = FALSE, quote = FALSE)
}

```


Now we can combine files that we re-ordered above.
```{bash, eval=FALSE}

# set up variables
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_DetectionGENOMES=$mainDIR/$projectID/13_DETECTED_GENOMES
DIR_SummaryPROF=$mainDIR/$projectID/08_PROFILE_SUMMARY
MAPPING_STATS=$DIR_DetectionGENOMES/${projectID}-mapping_stats_new.txt

# Run for loop to extract and transpose data frames

# add header
echo -e "layers\ttotal_reads_mapped\ttotal_reads_kept\tnum_SNVs_reported\tnum_SCVs_reported\tnum_INDELs_reported" >> $MAPPING_STATS

for site in BM TD PP PT PB TH KG SA HP 
do
MAPPING_STATS_SITE=$DIR_SummaryPROF/${projectID}_${site}-profile/misc_data_layers/default.txt_new.txt 
# add data
awk 'BEGIN{FS=OFS="\t"}NR>1{print $0}' $MAPPING_STATS_SITE >> $MAPPING_STATS
done
```

Download data from remote server.
```{bash, eval=FALSE}

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/13_DETECTED_GENOMES /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES

```

# 8. Detection, relative abundance and mean coverage plots

*See Neisseriaceae_realtive_abundance_plots.Rmd for detection, relative abundance and mean coverage plots*

# 9. G_0213 pangenome

##### 9.1 Annotate contig data bases with functions

Pfam database version ........................: 36.0 (2023-07)

```{bash, eval=FALSE}

clusterize -n 20 -m jgiacomini@forsyth.org -log LOGS/G_0213_contigs_functional_annotations.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/Mapping_profiling_scripts/script-01-contigsDB_annotation_pfams_cogs.sh P_0003_Neisseriaceae

```


#####  9.2 Pangenome

```{bash, eval=FALSE}

export BLASTDB_LMDB_MAP_SIZE=10000000000

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
COLLECTION=Genomes
site="SA"

DIR_MergedPROF=$mainDIR/$projectID/07_MERGED_PROFILE
DIR_DetectionGENOMES=$mainDIR/$projectID/13_DETECTED_GENOMES
DIR_SummaryPROF=$mainDIR/$projectID/08_PROFILE_SUMMARY
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME
DIR_ContigsDB=$mainDIR/$projectID/04_CONTIGS_DB

PROFILE_DB=$DIR_MergedPROF/${projectID}_${site}/PROFILE.db
CONTIGS_DB=$DIR_ContigsDB/${projectID}-contigs.db
INTERNAL=$DIR_Pangenome/${projectID}_G_0213-pangenome/internal_${projectID}.txt
genomes_G_0213=$mainDIR/$projectID/DATA/id_genomes-G_0213.txt
G_0213_bin_IDs=$mainDIR/$projectID/DATA/G_0213-name_conversions.txt
GENOMES_STORAGE=$DIR_Pangenome/${projectID}_G_0213-pangenome/${projectID}-GENOMES.db
PAN_RESULTS=$DIR_Pangenome/${projectID}_G_0213-pangenome/${projectID}-RESULTS
PAN_DB=$PAN_RESULTS/${projectID}-PAN.db
ANIb_RESULTS=$DIR_Pangenome/${projectID}_G_0213-pangenome/ANIb-RESULTS
ADD_INFO=$mainDIR/$projectID/DATA/$projectID-G_0213-add_info.items.txt
PAN_LAYERS=$DIR_Pangenome/${projectID}_G_0213-pangenome/${projectID}-add_info.layers.tsv


# Make pangenome directory
mkdir $DIR_Pangenome/${projectID}_G_0213-pangenome

# Make internal genome info file to be used for genome data base later
echo -e 'name\tbin_id\tcollection_id\tprofile_db_path\tcontigs_db_path' > $INTERNAL
cat $G_0213_bin_IDs | awk -v collection="$COLLECTION" -v profile_db="$PROFILE_DB" -v contigs_db="$CONTIGS_DB" 'BEGIN{FS=OFS="\t"}{print $1,$1,collection,profile_db,contigs_db}' >> $INTERNAL

# build annotated genome data base
clusterize -n 20 -m jgiacomini@forsyth.org -l LOGS/G_0213_genomes_storage.log anvi-gen-genomes-storage -i $INTERNAL --gene-caller prodigal -o $GENOMES_STORAGE

# build annotated pangenome
clusterize -n 20 -m jgiacomini@forsyth.org -l LOGS/G_0213_pangenome.log anvi-pan-genome -g $GENOMES_STORAGE --align-with muscle --use-ncbi-blast --minbit 0.5 --mcl-inflation 10 -n $projectID -o $PAN_RESULTS --num-threads 20 --enforce-hierarchical-clustering --I-know-this-is-not-a-good-idea


# create genome metadata $PAN_LAYERS 
G_0213_pangenome_IDs=$mainDIR/$projectID/DATA/G_0213_pangenome_IDs.txt
awk '{print $1}' $G_0213_name_conv > $G_0213_pangenome_IDs
grep -w -F -f $G_0213_pangenome_IDs -e item $ADD_INFO > $PAN_LAYERS

# import annotated reference genome metadata into pangenome
anvi-import-misc-data -p $PAN_DB -t layers $PAN_LAYERS --just-do-it
```


##### 9.3 Extract pangenome gene-cluster freq. tree

```{bash, eval=FALSE}
PanDir=$mainDIR/$projectID/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome

anvi-export-misc-data -p $PAN_DB --target-data-table layer_orders -o $PanDir/Layers_order
cat $PanDir/Layers_order | grep 'gene_cluster frequencies'| awk -F"\t" '{print $3}' >  $PanDir/gene_cluster_frequencies_newick

```

Send to local for detection plot:

```{bash, eval=FALSE}

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/ /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/G_0213/

```



##### 9.4 ANI for G_0213 pangenome

```{bash, eval=FALSE}

# add ANI (ANIb method) to annotated pangenome
#module load blast+/2.10.1
clusterize -n 20 -m jgiacomini@forsyth.org -l LOGS/G_0213_ANIb.log anvi-compute-genome-similarity -i $INTERNAL -o $ANIb_RESULTS --pan-db $PAN_DB --program pyANI --method ANIb --num-threads 20

```


##### 9.4 BAC_71 SCG Phylogeny

Make sure you are in the anvio-8 environment:

screen -S qrsh_sesh
qrsh -pe allslots 5

module load anvio/8-conda
module load clusters/barhal
module load jbpc

Manually add outgroup to contigs paths file, then extract and concatenate aa sequences for bacteria_71 collection: 

```{bash, eval=FALSE}
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Phylo=$mainDIR/$projectID/14_PHYLOGENOMICS
GENOMES_G_0213=$mainDIR/$projectID/DATA/$projectID-G_0213-contig_paths.txt
GENOMES_G_0213_with_outgroup=$mainDIR/$projectID/DATA/$projectID-G_0213-contig_paths_with_outgroup.txt
num_genomes=213
min_num_genomes=$( expr $num_genomes / 2 )

# manually add out-group to contigs path file
echo -e 'name\tcontigs_db_path' >> $GENOMES_G_0213_with_outgroup
cat $GENOMES_G_0213_with_outgroup $GENOMES_G_0213 >> $GENOMES_G_0213_with_outgroup
echo -e 'Burkholderia_cepacia_str_BC16_id_GCA_009586235_1\t/workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Burkholderia_cepacia_str_BC16_id_GCA_009586235_1.db' >> $GENOMES_G_0213_with_outgroup

anvi-get-sequences-for-hmm-hits --e $GENOMES_G_0213_with_outgroup --hmm-source Bacteria_71 --min-num-bins-gene-occurs $min_num_genomes --get-aa-sequences --concatenate-genes --return-best-hit --align-with muscle -o $DIR_Phylo/Neisseriaceae_G_0213_bac71_sequences_with_outgroup

```

Build trees for each group with trimal/IQtree:

```{bash, eval=FALSE}

# trimal removes all positions in the alignment with gaps in 50% or more of the sequences
trimal -in $DIR_Phylo/Neisseriaceae_G_0213_bac71_sequences_with_outgroup -out $DIR_Phylo/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa -gt 0.50 

# build ML tree with WAG model and bootstrap supoprt
iqtree -s $DIR_Phylo/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa -nt AUTO -m WAG -bb 1000 -o "Burkholderia_cepacia_str_BC16_id_GCA_009586235_1"

```

Plot tree in R

```{bash, eval=FALSE}
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa.contree /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa.contree
```


Scale bar indicates the number of substitutions per site.
```{r, eval= FALSE}
library(dendextend)
library(ape)
library(dplyr)
library(phytools)
library(phylogram)

MLtree<-ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa.contree")

pdf("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0213_ML_tree_with_outgroup_bac71_IQTree.pdf",
    width = 10, height = 12)
plot(MLtree, cex = 0.25, edge.width = 0.5)
nodelabels(text = MLtree$node.label,node=2:MLtree$Nnode+Ntip(MLtree),frame="none",adj=c(1.2,-0.5), cex = 0.2, col = "red")
add.scale.bar()
dev.off() 

```


Chronos and dropped outgroup:

```{r, eval= FALSE}

library(dendextend)
library(ape)
library(dplyr)
library(phytools)
library(phylogram)

MLtree<-ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa.contree")
MLtree_dropped_outgroup <- drop.tip(MLtree, "Burkholderia_cepacia_str_BC16_id_GCA_009586235_1")
dend_MLtree_dropped_outgroup <- ape::chronos(MLtree_dropped_outgroup)

pdf("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0213_ML_tree_no_outgroup_bac71_IQTree.pdf",
    width = 10, height = 12)
plot(dend_MLtree_dropped_outgroup, cex = 0.25, edge.width = 0.5)
nodelabels(text = MLtree_dropped_outgroup$node.label,node=2:MLtree_dropped_outgroup$Nnode+Ntip(MLtree_dropped_outgroup),frame="none",adj=c(1.2,-0.5), cex = 0.2, col = "red")
add.scale.bar()
dev.off() 


```

Save un-rooted tree as newick file that we can import into the pangenome:

```{r, eval=FALSE}

write.tree(dend_MLtree_dropped_outgroup, file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa.contree.newick")

```

Send to Barhal:

```{bash, eval=FALSE}

scp -r /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa.contree.newick jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa.contree.newick

```

##### 9.5 Add Bacteria 71 SCG phylogeny to pangenome

```{bash, eval=FALSE}

# Note that we built the SCG tree earlier
# import tree to pangenome
projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Phylo=$mainDIR/$projectID/14_PHYLOGENOMICS
phyName_bac71=Bac71_phylogeny
phyloTree_bac71=$DIR_Phylo/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa.contree.newick
ADD_phyloTree_bac71=$DIR_Phylo/${phyName_bac71}.layer_orders.tsv
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME
PAN_RESULTS=$DIR_Pangenome/${projectID}_G_0213-pangenome/${projectID}-RESULTS
PAN_DB=$PAN_RESULTS/${projectID}-PAN.db

awk -v phyCount="$phyName_bac71" 'BEGIN{FS=OFS="\t"}NR==1{print "item_name","data_type","data_value"}{print phyCount,"newick",$0}' $phyloTree_bac71 > $ADD_phyloTree_bac71

anvi-import-misc-data -t layer_orders -p $PAN_DB $ADD_phyloTree_bac71

```

##### 9.4 b. PAN SCG Phylogeny

screen -S qrsh_sesh
qrsh -pe allslots 10

module load anvio
module load clusters/barhal
module load jbpc

```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME
PAN_DB=$DIR_Pangenome/${projectID}_G_0213-pangenome/${projectID}-RESULTS/${projectID}-PAN.db
GENOMES_DB=$DIR_Pangenome/${projectID}_G_0213-pangenome/${projectID}-GENOMES.db
N_genomes=213


anvi-get-sequences-for-gene-clusters -g $GENOMES_DB \
                                     -p $PAN_DB \
                                     -o $DIR_Pangenome/single_copy_core_genes-fasta \
                                     --max-num-genes-from-each-genome 1 \
                                     --min-num-genomes-gene-cluster-occurs $N_genomes \
                                     --concatenate-gene-clusters 
```

Anvio reported "Your filters resulted in 222 gene clusters that contain a total of 47286 genes.". This means that a total of 222 single copy core genes were shared among the 213 genomes.  

Build trees for each group with trimal/IQtree:
  
```{bash, eval=FALSE}

# trimal removes all positions in the alignment with gaps in 50% or more of the sequences
trimal -in $DIR_Pangenome/single_copy_core_genes-fasta -out $DIR_Pangenome/single_copy_core_genes-fasta.clean.fa -gt 0.50 

# build ML tree with WAG model and bootstrap supoprt
iqtree -s $DIR_Pangenome/single_copy_core_genes-fasta.clean.fa -nt AUTO -m WAG -bb 1000 

```

Send to local...
```{bash, eval=FALSE}
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/single_copy_core_genes-fasta.clean.fa.contree /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/G_0213_Pangenome_single_copy_core_genes-fasta.clean.fa.contree
```


##### 9.6 Display pangenome

Send pangenome to local (easier to display)

```{bash, eval=FALSE}

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/ /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/G_0213/

```

Run on local!!

```{bash, eval=FALSE}

pan_dir=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/G_0213

anvi-display-pan -p $pan_dir/P_0003_Neisseriaceae-RESULTS/P_0003_Neisseriaceae-PAN.DB -g $pan_dir/P_0003_Neisseriaceae-GENOMES.db


```


I created a spaced and not_spaced version. Both are colored according to the G_0636 ANI figure.




##### 9.7 Re-extract custom pangeome gene-cluster freq tree

Extract from local pangenome with saved state files.

```{bash, eval=FALSE}
PanDir=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/G_0213

anvi-export-misc-data -p $PanDir/P_0003_Neisseriaceae-RESULTS/P_0003_Neisseriaceae-PAN.DB --target-data-table layer_orders -o $PanDir/Layers_order

# The following code will print the names of the different trees
cat $PanDir/Layers_order | awk -F"\t" '{print $1}'

# This code will extract the tree of choice into a new file
cat $PanDir/Layers_order | grep 'gene cluster freq custom'| awk -F"\t" '{print $3}' >  $PanDir/gene_cluster_frequencies_custom_newick

```


At this point I re-created the detection and coverage figures using the new genomes order file 'gene_cluster_frequencies_custom_newick'.


##### 9.8 Add gene cluster collection (Core, Acc. Singles)

We then generated gene cluster collections for Core: gene clusters shared between all genomes, Accessory: gene clusters shared between two or more genomes, but not all, and Singletons: gene clusters found only in a single genome.
```{bash make pangenome collection}
iDir=$DIR_Pangenome/internal_annotated_${projectID}
genomeDB=$iDir/${projectID}-GENOMES.db
panDB=$iDir/${projectID}-RESULTS/${projectID}-PAN.db
numGenomes="77"

# get all gene-clusters
anvi-get-sequences-for-gene-clusters -g $genomeDB -p $panDB --min-num-genomes-gene-cluster-occurs 1 -o $iDir/${projectID}-accessoryGC.temp.txt
# get genusCore gene-clusters
anvi-get-sequences-for-gene-clusters -g $genomeDB -p $panDB --min-num-genomes-gene-cluster-occurs $numGenomes -o $iDir/${projectID}-genusCoreGC.temp.txt
# get singleton gene-clusters
anvi-get-sequences-for-gene-clusters -g $genomeDB -p $panDB --max-num-genomes-gene-cluster-occurs 1 -o $iDir/${projectID}-singletonsGC.temp.txt

# make list with unique gene-cluster IDs for genusCore & singletons
# add bin name in second column
# append to cas3 collection file
cat $iDir/${projectID}-genusCoreGC.temp.txt | grep ">" | awk -F'|' '{print $2}' | sed -e 's/gene_cluster\://' | sort | uniq | awk 'BEGIN{FS=OFS="\t"}{print $1, "Genus_core"}' > $iDir/${projectID}-collection.cas3.txt
cat $iDir/${projectID}-singletonsGC.temp.txt | grep ">" | awk -F'|' '{print $2}' | sed -e 's/gene_cluster\://' | sort | uniq | awk 'BEGIN{FS=OFS="\t"}{print $1, "Singletons"}' >> $iDir/${projectID}-collection.cas3.txt

# remove genus core & singletons gene-cluster IDs from accessory file
# print only missing gene clusters from accessoryID
# add bin name in second column
# append to cas3 collection file
comm -23 <( cat $iDir/${projectID}-accessoryGC.temp.txt | grep ">" | awk -F'|' '{print $2}' | sed -e 's/gene_cluster\://' | sort | uniq ) <( cat $iDir/${projectID}-collection.cas3.txt | cut -f1 | sort | uniq) | awk 'BEGIN{FS=OFS="\t"}{print $1, "Accessory"}' >> $iDir/${projectID}-collection.cas3.txt

# make collection info file
echo -e "Genus_core\tUNKNOWN_SOURCE\t#870000" > $iDir/${projectID}-collection.cas3-info.txt
echo -e "Accessory\tUNKNOWN_SOURCE\t#f2f2f2" >> $iDir/${projectID}-collection.cas3-info.txt
echo -e "Singletons\tUNKNOWN_SOURCE\t#db9e04" >> $iDir/${projectID}-collection.cas3-info.txt

# import cas3 collection & info to pangenome
anvi-import-collection -p $panDB -C cas3 --bins-info $iDir/${projectID}-collection.cas3-info.txt $iDir/${projectID}-collection.cas3.txt

rm $iDir/*temp.txt
```


# 10. G_0213 ANI plot

Send results to local

```{bash, eval = FALSE}


scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/ANIb-RESULTS /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213

```



##### 10.1 Percent identity plot

```{r, eval=FALSE}

# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_percentage_identity.txt", header = TRUE)

# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_percentage_identity.newick")

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)



# get tick colors

# import colors df
# load csv file with genome IDs and colors; theis file was made when the tanglegram was made
bins_and_colors <-read.csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/pangenome_custom_gene_freq_order.csv", header = TRUE)

# Ensure 'Pangenome_ID' and 'key' are factors
bins_and_colors$Pangenome_ID <- as.factor(bins_and_colors$Pangenome_ID)

# Match the order of 'Pangenome_ID' in bins_and_colors to the order in 'key' of long_df
order_indices <- match(long_df$key, bins_and_colors$Pangenome_ID)

# Use the order_indices to reorder bins_and_colors
bins_and_colors_reordered <- bins_and_colors[order_indices, ]


group_tick_colors <- bins_and_colors_reordered$Group_color


# plot
plot<-ggplot(long_df, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.95,
                       limits =c(0.90, 1),
                       na.value="darkblue",
                        name = "ANI (%)")+
  #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black", size = 2),
        axis.text.y = element_text(color = "black", size = 2),
        axis.ticks.y = element_line(color = rev(group_tick_colors), size = 1),
        axis.ticks.x = element_line(color = rev(group_tick_colors), size = 1.3),
        axis.ticks.length=unit(.5, "cm")) 

# rows <- as.data.frame(df_newick$tip.label)
# height=nrow(rows) *0.3
# width=height*1.3
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANI_heatmap.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)

```


##### 10.2 Full percent identity plot

```{r, eval=FALSE}

# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_full_percentage_identity.txt", header = TRUE)

# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_full_percentage_identity.newick")

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)



# get tick colors

# import colors df
# load csv file with genome IDs and colors; theis file was made when the tanglegram was made
bins_and_colors <-read.csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/pangenome_custom_gene_freq_order.csv", header = TRUE)

# Ensure 'Pangenome_ID' and 'key' are factors
bins_and_colors$Pangenome_ID <- as.factor(bins_and_colors$Pangenome_ID)

# Match the order of 'Pangenome_ID' in bins_and_colors to the order in 'key' of long_df
order_indices <- match(long_df$key, bins_and_colors$Pangenome_ID)

# Use the order_indices to reorder bins_and_colors
bins_and_colors_reordered <- bins_and_colors[order_indices, ]


group_tick_colors <- bins_and_colors_reordered$Group_color


# plot
plot<-ggplot(long_df, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.75,
                       limits =c(0.5, 1),
                       na.value="darkblue",
                        name = "ANI (%)")+
  #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black", size = 2),
        axis.text.y = element_text(color = "black", size = 2),
        axis.ticks.y = element_line(color = rev(group_tick_colors), size = 1),
        axis.ticks.x = element_line(color = rev(group_tick_colors), size = 1.3),
        axis.ticks.length=unit(.5, "cm")) 

# rows <- as.data.frame(df_newick$tip.label)
# height=nrow(rows) *0.3
# width=height*1.3
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_full_percentage_identity_heatmap.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)

```

##### 10.3 Coverage 


Alignment coverage is the proportion of the query genome that aligns against the reference genome. This can be asymmetrical even when the alignment itself is symmetrical, as the genomes participating in a pairwise alignment may have differing amounts of genomic sequence that do not contribute to the alignment.

Percentage coverage matrix for Neisseria, Kingella, Eikenlla and Simonsiella ANIb analysis -  coverage is calculated as alignment length / genome length.

Each cell represents a pairwise comparison between the named genomes on rows and columns, and the number in each cell is the pairwise coverage of each genome by aligned regions in the comparison (i.e, Percentage coverage). The color scheme colors cells as white with a percentage coverage equal to 0.50, greater as red, and less than as s blue. This division corresponds to a strict majority of each genome in the comparison being align-able (a plausible ad hoc minimum requirement for two sequences being considered “the same thing”).


In our case, nearly all the pairwise comparisons between Eikenella species and Neisseria, Kingella and Simonsiella are blue cells below 50%. This indicates that the proportion of each genome that aligns is very small, and we are safe to assert that these organisms come from different genera. The exception to this is the comparison between BVAF and floridianus: their coverage is higher, at ≈15%. This may indicate a common plasmid or mobile element, or it may indicate a more recent common ancestor than the other comparisons; they may or may not validly be in the same genus - we would need to investigate further to understand their relationship.

The BPEN/640 comparison is conclusive, however. Their coverage/AF is essentially 100%, so these are closely-related, highly sequence-homologous organisms.

```{r, eval=FALSE}

# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_alignment_coverage.txt", header = TRUE)

# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_alignment_coverage.newick")

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)



# get tick colors

# import colors df
# load csv file with genome IDs and colors; theis file was made when the tanglegram was made
bins_and_colors <-read.csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/pangenome_custom_gene_freq_order.csv", header = TRUE)

# Ensure 'Pangenome_ID' and 'key' are factors
bins_and_colors$Pangenome_ID <- as.factor(bins_and_colors$Pangenome_ID)

# Match the order of 'Pangenome_ID' in bins_and_colors to the order in 'key' of long_df
order_indices <- match(long_df$key, bins_and_colors$Pangenome_ID)

# Use the order_indices to reorder bins_and_colors
bins_and_colors_reordered <- bins_and_colors[order_indices, ]


group_tick_colors <- bins_and_colors_reordered$Group_color


# plot
plot<-ggplot(long_df, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.5,
                       limits =c(0, 1),
                       na.value="darkblue",
                       name = expression(atop("ANIb alignment coverage", "(Coverage/Aligned Fraction)"))) + 
  #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black", size = 2),
        axis.text.y = element_text(color = "black", size = 2),
        axis.ticks.y = element_line(color = rev(group_tick_colors), size = 1),
        axis.ticks.x = element_line(color = rev(group_tick_colors), size = 1.3),
        axis.ticks.length=unit(.5, "cm")) 

# rows <- as.data.frame(df_newick$tip.label)
# height=nrow(rows) *0.3
# width=height*1.3
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_alignment_coverage_heatmap.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)

```

##### 10.4 Haddard matrix (Identity * coverage)

```{r, eval=FALSE}

# packages
library(ggplot2)
library(tidyr)
library(reshape2)
library(phytools)
library(tibble)
library(dendextend)
library(ape)
library(dplyr)

# load ANI data
df <-read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_hadamard.txt", header = TRUE)

# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_hadamard.newick")

# order ANI data by ANI tree
df_newick_orders <- phytools::compute.mr(df_newick, type = "matrix")
df_newick_rownames <- rev(rownames(df_newick_orders))
data_ordered <- df[ order(match(df$key, df_newick_rownames)), ]
df_newick_rownames_df <- as.data.frame(df_newick_rownames)
cols_A<- ncol(df) -1
df_newick_rownames_df2 <- as.data.frame(matrix(df_newick_rownames_df$df_newick_rownames, ncol = cols_A, byrow = TRUE))
names(df_newick_rownames_df2) <- df_newick_rownames_df2[1,]
df_newick_rownames_df3 <- df_newick_rownames_df2[-1,]
df_newick_rownames_df3 <- df_newick_rownames_df3 %>% 
  add_column(key = NA, .before = 1)
data_ordered2<-data_ordered[names(df_newick_rownames_df3)]

cols2<- ncol(data_ordered2) 
long_df <- reshape2::melt(data_ordered2,
                          id.vars=c("key"),
                          measure.vars=colnames(data_ordered2[2:cols2]),
                          variable.name="y",
                          value.name="z")
mylevels1 <- df_newick$tip.label
long_df$key <- factor(long_df$key,levels=mylevels1)
long_df$y <- factor(long_df$y, levels=mylevels1)



# get tick colors

# import colors df
# load csv file with genome IDs and colors; theis file was made when the tanglegram was made
bins_and_colors <-read.csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/pangenome_custom_gene_freq_order.csv", header = TRUE)

# Ensure 'Pangenome_ID' and 'key' are factors
bins_and_colors$Pangenome_ID <- as.factor(bins_and_colors$Pangenome_ID)

# Match the order of 'Pangenome_ID' in bins_and_colors to the order in 'key' of long_df
order_indices <- match(long_df$key, bins_and_colors$Pangenome_ID)

# Use the order_indices to reorder bins_and_colors
bins_and_colors_reordered <- bins_and_colors[order_indices, ]


group_tick_colors <- bins_and_colors_reordered$Group_color


# plot
plot<-ggplot(long_df, aes(key,y)) +
  geom_tile(aes(fill = z)) + 
  scale_fill_gradient2(low = "darkblue",
                       mid = "white",
                       high = "darkred",
                       midpoint = 0.75,
                       limits =c(0.5, 1),
                       na.value="darkblue",
                       name = expression(atop("ANIb Hadamard", "(% Identity * Coverage)"))) +
  #geom_text(aes(label = format(round(z, digits=3), nsmall = 3)),size=2.75) +
  ylab("") +  
  xlab("") + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black", size = 2),
        axis.text.y = element_text(color = "black", size = 2),
        axis.ticks.y = element_line(color = rev(group_tick_colors), size = 1),
        axis.ticks.x = element_line(color = rev(group_tick_colors), size = 1.3),
        axis.ticks.length=unit(.5, "cm")) 

# rows <- as.data.frame(df_newick$tip.label)
# height=nrow(rows) *0.3
# width=height*1.3
  
ggsave(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_hadamard_heatmap.pdf", plot = plot, width = 11, height = 8, limitsize = FALSE)

```

# 11. G_0213 Phylogeny and Pangenome tanglegram


##### 11.b. Tanglegram figure

```{r, eval=FALSE}

# load libraries
library(dendextend)
library(ape)
library(dplyr)
library(phytools)
library(phylogram)
library(gplots)

# load trees
PANtree<-ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/G_0213/gene_cluster_frequencies_custom_newick")

Bac_71_MLtree<-ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/14_PHYLOGENOMICS/Neisseriaceae_G_0213_bac71_sequences_with_outgroup.clean.fa.contree")

# remove outgroup from tree file for merging into pangenome and making tanglegram
Bac_71_MLtree <- drop.tip(Bac_71_MLtree, "Burkholderia_cepacia_str_BC16_id_GCA_009586235_1")

# convert to dendrogram objects
dend_Bac_71_MLtree <- ape::chronos(Bac_71_MLtree)
dend_Bac_71_MLtree_2 <- as.dendrogram.phylo(dend_Bac_71_MLtree)
dend_PANtree <- ape::chronos(PANtree)
dend_PANtree_2 <- rev(as.dendrogram.phylo(dend_PANtree))
# load colors df
bins_and_colors <-read.csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/pangenome_custom_gene_freq_order.csv", header = TRUE)

# Ensure 'Pangenome_ID' and 'key' are factors
bins_and_colors$Pangenome_ID <- as.factor(bins_and_colors$Pangenome_ID)

#### Pangenome colors ####
# # Extract labels from pangenome dendrogram 
pan_labels <- dend_PANtree_2 %>% set("labels_to_char") %>% labels 

# Match the order of 'Pangenome_ID' in bins_and_colors to the order in 'key' of long_df
Pan_order_indices <- match(pan_labels, bins_and_colors$Pangenome_ID)

# Use the order_indices to reorder bins_and_colors
Pan_bins_and_colors_reordered <- bins_and_colors[Pan_order_indices, ]

# set color variable for plotting
Pan_group_colors <- Pan_bins_and_colors_reordered$Group_color


#### Phylo colors ####
# # Extract labels from bac71 phylo dendrogram 
bac71_phylo_labels <- dend_Bac_71_MLtree_2 %>% set("labels_to_char") %>% labels 

# Match the order of 'Pangenome_ID' in bins_and_colors to the order in 'key' of long_df
Phylo_order_indices <- match(bac71_phylo_labels, bins_and_colors$Pangenome_ID)

# Use the order_indices to reorder bins_and_colors
Phylo_bins_and_colors_reordered <- bins_and_colors[Phylo_order_indices, ]

# set color variable for plotting
Phylo_group_colors <- Phylo_bins_and_colors_reordered$Group_color

# make dendrogram list; second dedrogram will be fixed
bac71_SCG_PAN <- dendlist(dend_Bac_71_MLtree_2 %>% 
    set("labels_col", value = Phylo_group_colors),
    dend_PANtree_2 %>% 
      set("labels_col", value = Pan_group_colors)) 


# set height for pdf
rows <- as.data.frame(Bac_71_MLtree$tip.label)
height=nrow(rows) *0.0825

# build tanglegram
bac71_SCG_PAN_TANGLEGRAM <- bac71_SCG_PAN %>% dendextend::untangle(method="step1side") 

# set colors of lines; needs to be based on lefthand side dendrogram
bac71_PAN_TANGLEGRAM_labels <- bac71_SCG_PAN_TANGLEGRAM[[1]] %>%  labels
bac71_PAN_TANGLEGRAM_labels <- as.data.frame(bac71_PAN_TANGLEGRAM_labels)

line_colors <- merge(bac71_PAN_TANGLEGRAM_labels, Phylo_bins_and_colors_reordered, by.x="bac71_PAN_TANGLEGRAM_labels", by.y="Pangenome_ID", sort=F)
line_colors2 <- as.character(line_colors$Group_color)
line_colors3 <- col2hex(line_colors2)

# plot tanglegram
pdf(file = "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/FIGURES/Phylogenies/G_0213_Phylogeny_vs_pangenome_tanglegram.pdf", width = 15, height = height) 

bac71_SCG_PAN_TANGLEGRAM %>% plot(common_subtrees_color_lines=FALSE,
                                  highlight_distinct_edges=FALSE,
                                  common_subtrees_color_branches=FALSE,
                                  highlight_branches_lwd=FALSE,
                                  lwd=3, 
                                  lab.cex = 0.65, edge.lwd = 2, 
                                  margin_inner = 20, 
                                  columns_width = c(1, 0.5, 1), 
                                  axes=FALSE,
                                  color_lines = line_colors3)



dev.off()


```

Print ANI tree

```{r, eval=FALSE}



# load ANI tree
df_newick <-  ape::read.tree("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_percentage_identity.newick")

  
# create dedrogram object
dend_df_newick <- ape::chronos(df_newick)
dend_df_newick_2 <- as.dendrogram.phylo(dend_df_newick)

# create rectangular lines object
ddata <- dendro_data(dend_df_newick_2, type = "rectangle")

ANI_dend_plot <- ggplot(segment(ddata)) + 
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend), linewidth = 1) + 
  coord_flip() + 
  scale_y_reverse(expand = c(0.2, 0)) +
  scale_x_reverse() +
  theme_classic() +
  theme(axis.ticks.y = element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.x = element_blank(),
        axis.text.y =  element_blank(),
        axis.line.x = element_blank(),
        axis.line.y = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_blank()) +
  theme(panel.spacing.x=unit(0.05, "lines"),
        plot.margin=unit(c(0,0,0,0), "cm"))

# save dend plot
ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/ANI/G_0213/ANIb_percentage_identity_dendrogram.pdf",ANI_dend_plot, width = 5, height = 7)



```


# 12. Grouping genomes based on ANI and Phylogeny

For comparative genomics, we want to group genomes based on their site preferences. Grouping can be based on several measures, including, breadth of coverage and depth of coverage, or their combination. Moreover, grouping can be based on the detection of a genome in a certain fraction of samples in an oral site compared to other oral sites. For example, if genome A is detected in 30% of TD samples, 5% of BM and 3% of SUPP, we can assign genome A to a TD group with reasonable confidence. 

To automate the process of grouping genomes based on their site preferences using statistical tests in R, we can employ a combination of data manipulation and statistical testing techniques. Given the structure of the data frame and the inclusion of co-variates like subject ID, total number of reads, and visit number, a logistic regression model or a Chi-square test could be appropriate. 

First, aggregate the data by genome and site to calculate the proportion of samples in which each genome is detected at each site. Then use logistic regression to model the binary outcome as a function of the site, including other covariates (subject ID, total reads, visit number). This model will allow us to assess the impact of these variables on genome detection. Alternatively, we can use a Chi-Square test for a simpler approach. 

Based on the results from statistical tests, set a threshold (like the 30% in the example above) to assign genomes to groups.

The central goal of this analysis is to classify genomes based on their site preferences. The process is  designed to evaluate the coverage of genomes across various oral sites, thereby assigning each genome to a group where it demonstrates the highest detection frequency. Here, we classify a genome as detected in a sample if it's breadth of coverage was at least 50%. Such classification can reveal 'specialist' genomes that show a high propensity for a particular site over others, indicative of a nuanced ecological adaptation or symbiosis.

By automating the grouping process through a bespoke R function, we are streamlining what would otherwise be an immensely time-consuming task. In addition, incorporating logistic regression models allows for the assessment of covariates, such as total number of reads, which may influence genome detection. A threshold-based approach for assignment provides a quantifiable measure to delineate group membership, thus avoiding arbitrary classification.

The findings from this analysis have profound implications for downstream comparative genomics. By identifying site specialists, we can delve deeper into the genetic determinants of niche adaptation. The nuanced understanding gleaned from this analysis can also inform therapeutic strategies, guide microbiome research, and enhance our grasp of microbial ecology.

The analysis was designed to classify genomes by site preference based on detection probabilities. Initially, the dataset was organized by genome with relevant covariates prepared for inclusion in the statistical models. For each genome, we used logistic regression to model the probability of detection as a function of the site, adjusting for the covariate total number of reads.

Posthoc Tukey tests provided pairwise comparisons between sites for each genome to assess statistical significance in detection differences. Genomes were then classified based on their highest detection probability across sites, with a set threshold of at least 1% to avoid misclassification due to low probabilities which could suggest non-specificity.

For visual analysis, bar plots were generated for each genome showing detection probabilities across sites, with significant pairwise differences annotated. This methodological approach allows us to systematically identify site-specific genomes, which is critical for comparative genomic analysis and understanding genomic adaptations to different sites.


```{r, eval=FALSE}

library(dplyr)
library(ggplot2)
library(emmeans)
library(multcomp)
library(car)
library(ggsignif)

melted_strain_detection <- read.csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/Strain_level_updated_detection_data.csv", header = TRUE)

melted_strain_detection$bins <- as.factor(melted_strain_detection$bins)

perform_analysis <- function(data, genome_list, output_dir) {
  if (!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
  # Initialize an empty list to store individual genome data frames
  all_genomes_df <- list()
  
  for(genome in genome_list) {
    subset_data <- data %>% filter(bins == genome)
    
    subset_data$site <- as.factor(subset_data$site)
    subset_data$total_number_reads <- as.numeric(subset_data$total_number_reads)
    
    model <- glm(detection_binary ~ site + total_number_reads, family = binomial(link = "logit"), data = subset_data)
    
    # Estimated Marginal Means
    em <- emmeans(model, "site", type = "response")
    em_df <- as.data.frame(em)
    
    # Add a new column to em_df for the genome name
    em_df$genome <- genome
    
    # Append the data frame for this genome to the list
    all_genomes_df[[genome]] <- em_df
    
    write.csv(em_df, file = paste0(output_dir, "/", genome, "_emm.csv"), row.names = FALSE)
    
    # Posthoc Test
    posthoc_result <- contrast(em, "pairwise", adjust = "Tukey")
    #posthoc_df <- summary(posthoc_result)
    posthoc_df <- as.data.frame(summary(posthoc_result))[c('contrast', 'odds.ratio', 'SE', 'df', 'null', 'z.ratio', 'p.value')]
    write.csv(posthoc_df, file = paste0(output_dir, "/", genome, "_posthoc.csv"), row.names = FALSE)
    
    
    # Extract significant comparisons
    sig_comparisons <- posthoc_df %>%
      dplyr::mutate(contrast_split = strsplit(as.character(contrast), " / ")) %>%
      dplyr::mutate(group1 = sapply(contrast_split, function(x) x[1]),
             group2 = sapply(contrast_split, function(x) x[2])) %>%
      dplyr::mutate(stars = case_when(
        p.value < 0.001 ~ "***",
        p.value < 0.01 ~ "**",
        p.value < 0.05 ~ "*",
        TRUE ~ "NS"  # For p-values not covered by the above conditions
      )) %>%
      dplyr::select(group1, group2, p.value, stars)

    
    # Bar Plot with Significance Levels
    plot <- ggplot(em_df, aes(x = site, y = prob)) + 
      geom_bar(stat = "identity", position = position_dodge()) +
      geom_errorbar(aes(ymin = prob - SE, ymax = prob + SE), width = 0.2, position = position_dodge(0.9)) +
      scale_y_continuous(limits = c(0, 1), expand = c(0, 0), breaks = c(0, 0.25, 0.5, 0.75, 1)) + 
      ggtitle(paste(genome)) +
      xlab("Oral site") + ylab("Probability of detection") +
      theme_classic()
    
    
    # Save plot
    ggsave(filename = paste0(output_dir, "/", genome, "_plot.pdf"), plot = plot, width = 7, height = 5)
    
    # Combine all individual genome data frames into one data frame
    final_df <- bind_rows(all_genomes_df)
  
    # Save the final combined data frame to a CSV file
    write.csv(final_df, file = paste0(output_dir, "/combined_genome_data.csv"), row.names = FALSE)
  
  }
}

# Run it...
perform_analysis(melted_strain_detection, unique(melted_strain_detection$bins), "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/Prop_detected")


```


```{r}

library(dplyr)
library(readr)

# Load the data from the CSV file
data <- read_csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/Prop_detected/combined_genome_data.csv")

# Define the threshold for the maximum probability
threshold_prob <- 0.01

# Identify the site with the highest probability for each genome and classify as a specialist
# Assign NA if the max probability is equal to the threshold
specialist_df <- data %>%
  group_by(genome) %>%
  summarize(max_prob = max(prob),
            specialist_site = ifelse(max_prob < threshold_prob, NA, site[which.max(prob)]),
            .groups = 'drop')

# View the classification
print(specialist_df)

# Optionally, save the classification to a new CSV file
write_csv(specialist_df, "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/Prop_detected/specialist_classification.csv")

```



In this analysis, our objective was to categorize genomes into specialists based on their site preferences within the oral cavity, focusing on four specific sites: SUPP, KG, BM, and TD. This selection was driven by a desire to minimize noise from less relevant sites and to consider the sample size consistency across the chosen sites—except for KG, which was included due to its importance for the N. cinerea species group, known to be a KG specialist.

The dataset was filtered to include only these sites, thus refining our analysis to the environments of greatest interest. A threshold for maximum probability was established to discern genuine site specificity from random detection. Genomes with a detection probability at any site below this threshold were not classified, avoiding mislabeling generalists as specialists.

For each genome, we calculated the maximum detection probability across the selected sites and assigned the corresponding site as the specialist site, except where the maximum probability was below the threshold, which resulted in an NA classification. This methodical approach allowed us to pinpoint genomes with a strong affinity for one of the four selected oral sites, providing a clearer view of site-specific adaptations.

The filtered classification was saved to a new CSV file, enabling further comparative genomic studies focused on these key oral sites. This targeted approach enhances our ability to detect meaningful patterns of specialization, particularly for species like N. cinerea at the KG site, and to understand how these patterns may contribute to niche adaptation within the oral microbiome.

Additionally, I added the pangenomic groupings.

```{r}

library(dplyr)
library(readr)

# Load the data from the CSV file
data <- read_csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/Prop_detected/combined_genome_data.csv")

data_filtered <- data %>% 
  dplyr::filter(site == "SUPP" | site == "KG" | site == "BM" | site == "TD")


# Define the threshold for the maximum probability
threshold_prob <- 0.001

# Identify the site with the highest probability for each genome and classify as a specialist
# Assign NA if the max probability is equal to the threshold
specialist_df_filtered <- data_filtered %>%
  group_by(genome) %>%
  summarize(max_prob = max(prob),
            specialist_site = ifelse(max_prob < threshold_prob, NA, site[which.max(prob)]))

# Add data fro pangenomic groupings
bins_and_colors <-read_csv("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/pangenome_custom_gene_freq_order.csv")

# Ensure 'Pangenome_ID' and 'key' are factors
bins_and_colors$Pangenome_ID <- as.factor(bins_and_colors$Pangenome_ID)

# Merge pangenomic grouping df with main df.
specialist_df_filtered_merged <- merge(specialist_df_filtered,bins_and_colors, by.x = "genome", by.y = "Pangenome_ID" )


# View the classification
print(specialist_df_filtered_merged)

# Optionally, save the classification to a new CSV file
write_csv(specialist_df_filtered_merged, "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/Prop_detected/specialist_classification_filtered.csv")

```


It is apparent from the analysis that there are three main oral sites that Nesseriaceae taxa specialize on, including plaque (SUPP and SUBP), keratinized gingiva, and the tongue dorsum. An exception can be made for Kingella oralis/bonacorsii, which appears to have high prevalence in both plaque and keratinzed gingiva, as well as some prevalence in buccal mucosa. Thus, the marked difference in distribution of certain Nesseriaceae taxa suggests different functional roles caused by genomic differences. For example, what are the genomic traits that differentiate N. cinerea KG specialist from N. subflava TD specialists, or plaque specialists that are not also prevalent in KG samples?

Plaque specialists appear to include Eikenella species (corrodens, exigua and halliae), K. denitrificans,  K. oralis/bonacorsii, an unnamed K. sp. (str_SNUBH_2017), N_bacilliformis, N. elongata, N_oralis, the N. mucosa group and some members of the N_subflava_group. Within the group of plaque specialists, 

Tongue dorsum specialists include members from the N. subflava group (perflava, subflava and flavescens).

Keratinized gingiva specialists inlcude N. cinerea and S. muelleri. 

##### 12.2. Grouping genomes based on ANI




# 13. Functional enrichment analyses

First we need to estimate metabolic pathway completeness for each genome in the G_0213 set. 

```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab

DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME
DIR_ContigsDB=$mainDIR/$projectID/04_CONTIGS_DB
DIR_Annotation=$mainDIR/$projectID/12_FUNCTIONAL_ANNOTATION

CONTIGS_DB=$DIR_ContigsDB/${projectID}-contigs.db
INTERNAL=$DIR_Pangenome/${projectID}_G_0213-pangenome/internal_${projectID}.txt

mkdir $DIR_Annotation/KEGG_Metabolic_pathways

# note that we need to run both of these ; the second because we need the modules.txt file for estimating module enrichment

clusterize -n 10 -m jgiacomini@forsyth.org -l LOGS/G_0213_Estimate_metabolism.log anvi-estimate-metabolism -i $INTERNAL -O $DIR_Annotation/KEGG_Metabolic_pathways/${projectID}-MetabolicPaths --matrix-format --include-metadata

clusterize -n 10 -m jgiacomini@forsyth.org -l LOGS/G_0213_Estimate_metabolism.log anvi-estimate-metabolism -i $INTERNAL -O $DIR_Annotation/KEGG_Metabolic_pathways/${projectID}-MetabolicPaths --output-modes modules


```

```{bash, eval=FALSE}
# send grouping info to server (RUN ON LOCAL)
scp -r /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/13_DETECTED_GENOMES/Prop_detected/SUPP_KG_TD_group_file.txt jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/12_FUNCTIONAL_ANNOTATION/SUPP_KG_TD_group_file.txt

```

Now we need to add the genome grouping info to the pangenome so that we can run   
anvi-compute-functional-enrichment-in-pan. The grouping txt file needs to have one column called "item", which contains the pangenome IDs, and one column for the grouping variable, which in our case will be called "Habitat_Preference" and will contain either TD, SUPP, KG or NONE. 

First, lets edit the groupings file appropriately. 

```{bash, eval=FALSE}

# Paths to files
original_groupings="/workspace/jmarkwelchlab/P_0003_Neisseriaceae/12_FUNCTIONAL_ANNOTATION/SUPP_KG_TD_group_file.txt"
pangenome_groupings="/workspace/jmarkwelchlab/P_0003_Neisseriaceae/12_FUNCTIONAL_ANNOTATION/SUPP_KG_TD_pangenome_groups_file.txt"
pangenomeIDs="/workspace/jmarkwelchlab/P_0003_Neisseriaceae/DATA/G_0213_pangenome_IDs.txt"

# Copy original_groupings text file to pangenome_groupings text file
echo -e "item\tHabitat_Preference" > $pangenome_groupings
cat $original_groupings | awk 'NR>1' >> $pangenome_groupings

# Find missing pangenome IDs and add them with "NONE" as Habitat_Preference
awk 'NR==FNR {ids[$1]; next} !($1 in ids)' $pangenome_groupings $pangenomeIDs | awk '{print $1"\tNONE"}' >> $pangenome_groupings


```


```{bash, eval=FALSE}

# Paths to files
projectID="P_0003_Neisseriaceae"
mainDIR="/workspace/jmarkwelchlab"
pangenome_groupings="$mainDIR/$projectID/12_FUNCTIONAL_ANNOTATION/SUPP_KG_TD_pangenome_groups_file.txt"
PAN="$mainDIR/$projectID/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/P_0003_Neisseriaceae-RESULTS/P_0003_Neisseriaceae-PAN.db"

anvi-import-misc-data -p $PAN -t layers $pangenome_groupings

```


##### 13.1 anvi-compute-functional-enrichment-in-pan

Now we can run anvi-compute-functional-enrichment-in-pan.

```{bash, eval=FALSE}

mkdir 20_FUNCTIONAL_ENRICHMENT

projectID="P_0003_Neisseriaceae"
mainDIR="/workspace/jmarkwelchlab"
PAN="$mainDIR/$projectID/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/P_0003_Neisseriaceae-RESULTS/P_0003_Neisseriaceae-PAN.db"
GENOMES="$mainDIR/$projectID/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/P_0003_Neisseriaceae-GENOMES.db"
OUT_DIR="$mainDIR/$projectID/20_FUNCTIONAL_ENRICHMENT"


for annotation_source in Pfam KEGG_Class KEGG_BRITE COG20_PATHWAY KEGG_Module COG20_CATEGORY KOfam COG20_FUNCTION
do
anvi-compute-functional-enrichment-in-pan -p $PAN -g $GENOMES -o $OUT_DIR/${annotation_source}_Pangenome_Enrichment.txt --category-variable Habitat_Preference --annotation-source $annotation_source --functional-occurrence-table-output $OUT_DIR/${annotation_source}_Pangenome_FUNC_OCCURRENCE.TXT
done


anvi-compute-functional-enrichment-in-pan -p $PAN -g $GENOMES -o $OUT_DIR/GC_IDENTITY_Pangenome_Enrichment.txt --category-variable Habitat_Preference --functional-occurrence-table-output $OUT_DIR/GC_IDENTITY_Pangenome_FUNC_OCCURRENCE.TXT --annotation-source IDENTITY --include-gc-identity-as-function


# send to local

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/20_FUNCTIONAL_ENRICHMENT /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/


```



##### 13.2 anvi-compute-metabolic-enrichment

```{bash, eval=FALSE}


projectID="P_0003_Neisseriaceae"
mainDIR="/workspace/jmarkwelchlab"
DIR_Annotation=$mainDIR/$projectID/12_FUNCTIONAL_ANNOTATION
OUT_DIR="$mainDIR/$projectID/20_FUNCTIONAL_ENRICHMENT"
pangenome_groupings="$DIR_Annotation/SUPP_KG_TD_pangenome_groups_file.txt"

cp $pangenome_groupings "$DIR_Annotation/SUPP_KG_TD_pangenome_groups_file_for_KEGG_Pathways_enrich_test.txt"
pangenome_groupings2="$DIR_Annotation/SUPP_KG_TD_pangenome_groups_file_for_KEGG_Pathways_enrich_test.txt"

# Run ernichment test. 
anvi-compute-metabolic-enrichment -M $DIR_Annotation/KEGG_Metabolic_pathways/${projectID}-MetabolicPaths_modules.txt -G $pangenome_groupings2 -o $OUT_DIR/KEGG_Metabolic_Pathway_Enrichment.txt

# send results to local (RUN ON LOCAL)
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/KEGG_Metabolic_Pathway_Enrichment.txt /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/KEGG_Metabolic_Pathway_Enrichment.txt

```


COG20_CATEGORY, KOfam, Pfam, COG20_FUNCTION, COG20_PATHWAY, KEGG_Module, KEGG_Class

We made use of anvi’o script anvi-compute-functional-enrichment to identify functional annotations that are differentially enriched or depleted in one set of genomes compared to another. First each genome was assigned to a group (oral site). Then, the script associated each gene cluster with the most frequently annotated function and generated a frequency table of functions across genomes. Finally, the enrichment test was done using a generalized linear model with a logit linkage function to obtain the enrichment score and a p-value. This analysis was performed for COG20, Pfams and KEGG annotations independently and the results were combined based on the gene cluster id.




###### ALT: COG20 FUNCTIONS

Run anvi-display-functions to execute functional enrichment test on COG20 functions.

```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Annotation=$mainDIR/$projectID/12_FUNCTIONAL_ANNOTATION
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME
INTERNAL=$DIR_Pangenome/${projectID}_G_0213-pangenome/internal_${projectID}.txt
GENOMES=$DIR_Pangenome/${projectID}_G_0213-pangenome/${projectID}-GENOMES.db

anvi-display-functions -g $GENOMES \
         --groups-txt $DIR_Annotation/SUPP_KG_TD_group_file.txt \
         --annotation-source COG20_FUNCTION \
         --profile-db $DIR_Annotation/COG20_Function/SUPP_KG_TD-COG20_FUNCTION-PROFILE.db \
         | tee LOGS/SUPP_KG_TD-COG20_FUNCTION.log
```


Move results to proper folder.

```{bash, eval=FALSE}

mv /usr/local/tmp/tmpxdq0ayb6/FUNC_OCCURENCE_STATS.txt $DIR_Annotation/COG20_Function/SUPP_KG_TD-COG20_FUNCTION-FUNC_OCCURENCE_STATS.txt
mv /usr/local/tmp/tmpxdq0ayb6/FUNC_ENRICHMENT_OUTPUT.txt $DIR_Annotation/COG20_Function/SUPP_KG_TD-COG20_FUNCTION-FUNC_ENRICHMENT_OUTPUT.txt
```

Send to local.

```{bash, eval=FALSE}

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/12_FUNCTIONAL_ANNOTATION/COG20_Function /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/12_FUNCTIONAL_ANNOTATION/

```


###### ALT: Pfams

Run anvi-display-functions to execute functional enrichment test on Pfams.

```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Annotation=$mainDIR/$projectID/12_FUNCTIONAL_ANNOTATION
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME
INTERNAL=$DIR_Pangenome/${projectID}_G_0213-pangenome/internal_${projectID}.txt
GENOMES=$DIR_Pangenome/${projectID}_G_0213-pangenome/${projectID}-GENOMES.db

mkdir $DIR_Annotation/Pfam

anvi-display-functions -g $GENOMES \
         --groups-txt $DIR_Annotation/SUPP_KG_TD_group_file.txt \
         --annotation-source Pfam \
         --profile-db $DIR_Annotation/Pfam/SUPP_KG_TD-Pfam-PROFILE.db \
         | tee LOGS/SUPP_KG_TD-Pfam
         
```


Move results to proper folder.

```{bash, eval=FALSE}

mv /usr/local/tmp/tmpeliu0l_d/FUNC_OCCURENCE_STATS.txt $DIR_Annotation/Pfam/SUPP_KG_TD-Pfam-FUNC_OCCURENCE_STATS.txt
mv /usr/local/tmp/tmpeliu0l_d/FUNC_ENRICHMENT_OUTPUT.txt $DIR_Annotation/Pfam/SUPP_KG_TD-Pfam-FUNC_ENRICHMENT_OUTPUT.txt
```

Send to local.

```{bash, eval=FALSE}

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/12_FUNCTIONAL_ANNOTATION/Pfam /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/12_FUNCTIONAL_ANNOTATION/

```

###### ALT: COG20_PATHWAYS

```{bash, eval=FALSE}

projectID=P_0003_Neisseriaceae
mainDIR=/workspace/jmarkwelchlab
DIR_Annotation=$mainDIR/$projectID/12_FUNCTIONAL_ANNOTATION
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME
INTERNAL=$DIR_Pangenome/${projectID}_G_0213-pangenome/internal_${projectID}.txt
GENOMES=$DIR_Pangenome/${projectID}_G_0213-pangenome/${projectID}-GENOMES.db

mkdir $DIR_Annotation/COG20_PATHWAY

anvi-display-functions -g $GENOMES \
         --groups-txt $DIR_Annotation/SUPP_KG_TD_group_file.txt \
         --annotation-source COG20_PATHWAY \
         --profile-db $DIR_Annotation/COG20_PATHWAY/SUPP_KG_TD-COG20_PATHWAY-PROFILE.db \
         | tee LOGS/SUPP_KG_TD-COG20_PATHWAY
         
```

Move results to proper folder.

```{bash, eval=FALSE}

mv /usr/local/tmp/tmpu4gvz9eh/FUNC_OCCURENCE_STATS.txt $DIR_Annotation/COG20_PATHWAY/SUPP_KG_TD-COG20_PATHWAY-FUNC_OCCURENCE_STATS.txt
mv /usr/local/tmp/tmpu4gvz9eh/FUNC_ENRICHMENT_OUTPUT.txt $DIR_Annotation/COG20_PATHWAY/SUPP_KG_TD-COG20_PATHWAY-FUNC_ENRICHMENT_OUTPUT.txt

```

Send to local.

```{bash, eval=FALSE}

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/12_FUNCTIONAL_ANNOTATION/COG20_PATHWAY /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/12_FUNCTIONAL_ANNOTATION/

```

# 14. Metapangenome


##### Generate oral site layers for metapangenome. 

Run after profile summary complete.

```{bash Generate oral site layers for metapangenome}
# LAYERS from metadata and merge with mapping reads and relative mapping
projectID="P_0003_Neisseriaceae"
mainDIR="/workspace/jmarkwelchlab"
DIR_Data="$mainDIR/$projectID/DATA"
DIR_SummaryPROF="$mainDIR/$projectID/08_PROFILE_SUMMARY"
mapIntermediate="$DIR_Data/mapping-reads.intermediate.tsv"
samplesMetadata="$DIR_Data/sequencing-metadata-count-QC.txt"
LAYER_ORDERS="$DIR_Data/$projectID-1297-layer_orders.txt"
sequencing_metadata="$mainDIR/HMP_SAMPLE_DATA/Final_1297_HMP_metagenomes_metadata.txt"
samples="$mainDIR/$projectID/samples_id-QC_IDs.txt"

# Update samples metadata
input="HMP_SAMPLE_DATA/Final_1297_HMP_metagenomes_metadata.csv"
output="HMP_SAMPLE_DATA/Final_1297_HMP_metagenomes_metadata.txt"
# Remove quotes and convert to tab-separated
sed 's/"//g' $input | awk 'BEGIN {FS=","; OFS="\t"} {$1=$1; print}' > $output

# Get sample IDs and total number of mapped reads
for site in PP PB BM KG TD PT HP TH SA 
do
siteLayers=$DIR_SummaryPROF/${projectID}_${site}-profile/misc_data_layers/default.txt
awk -F'\t' -v OFS="\t" 'NR==1 {for (i=1; i<=NF; i++) {f[$i] = i}} { print $(f["layers"]), $(f["total_reads_mapped"])}' $siteLayers | awk 'BEGIN{FS=OFS="\t"}NR>1{print $1,$2}' >> $mapIntermediate
done


# Write the header
echo -e "Sample_ID\tOral_site\tSubject_gender\tTotal_reads\tMapping_reads\tRel_map_reads" > $samplesMetadata
for metagenome in `cat samples_id-QC_IDs.txt`
do
META=$(cat $sequencing_metadata | grep -w "$metagenome" | awk 'BEGIN{FS=OFS="\t"}{print $1,$2,$13,$19}')
MAP=$(cat $mapIntermediate | grep -w "$metagenome" | awk 'BEGIN{FS=OFS="\t"}{print $2}')
echo -e "$META\t$MAP" | awk 'BEGIN{FS=OFS="\t"}{print $1,$2,$3,$4,$5,$6=((100 * $5 )/ ($4 * 2))}' >> $samplesMetadata
done
rm $mapIntermediate



# generate LAYER_ORDERS file
# order samples using multiple conditions (intermediate files)
for site in PP PB BM KG TD PT HP TH SA 
do
# Abundance
awk 'BEGIN{FS=OFS="\t"}NR>1{ print $1,$2,$6}' $samplesMetadata | sort -k2,2 -k3,3n | cut -f1 > Abundance.intermediate.layer_orders.tsv
# Site_abundance
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$6}' $samplesMetadata | sort -k2,2 -k3,3n | cut -f1 >> Site_abundance.intermediate.layer_orders.tsv
# Site_abundance_reverse
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$6}' $samplesMetadata | sort -k2,2 -k3,3nr | cut -f1 >> Site_abundance_reverse.intermediate.layer_orders.tsv
# Site_reverse_abundance
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$6}' $samplesMetadata | sort -k2,2r -k3,3n | cut -f1 >> Site_reverse_abundance.intermediate.layer_orders.tsv
# Site_reverse_abundance_reverse
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$6}' $samplesMetadata | sort -k2,2r -k3,3nr | cut -f1 >> Site_reverse_abundance_reverse.intermediate.layer_orders.tsv
# Site_mapped_reads
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$5}' $samplesMetadata | sort -k2,2 -k3,3n | cut -f1 >> Site_mapped_reads.intermediate.layer_orders.tsv
# Site_mapped_reads_reverse
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$5}' $samplesMetadata | sort -k2,2 -k3,3nr | cut -f1 >> Site_mapped_reads_reverse.intermediate.layer_orders.tsv
# Site_reverse_mapped_reads
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$5}' $samplesMetadata | sort -k2,2r -k3,3n | cut -f1 >> Site_reverse_mapped_reads.intermediate.layer_orders.tsv
# Site_reverse_mapped_reads_reverse
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$5}' $samplesMetadata | sort -k2,2r -k3,3nr | cut -f1 >> Site_reverse_mapped_reads_reverse.intermediate.layer_orders.tsv
# Site_total_reads
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$4}' $samplesMetadata | sort -k2,2 -k3,3n | cut -f1 >> Site_total_reads.intermediate.layer_orders.tsv
# Site_total_reads_reverse
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$4}' $samplesMetadata | sort -k2,2 -k3,3nr | cut -f1 >> Site_total_reads_reverse.intermediate.layer_orders.tsv
# Site_reverse_total_reads
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$4}' $samplesMetadata | sort -k2,2r -k3,3n | cut -f1 >> Site_reverse_total_reads.intermediate.layer_orders.tsv
# Site_reverse_total_reads_reverse
awk -v SITE="$site" 'BEGIN{FS=OFS="\t"}NR>1{if( $1 ~SITE) print $1,$2,$4}' $samplesMetadata | sort -k2,2r -k3,3nr | cut -f1 >> Site_reverse_total_reads_reverse.intermediate.layer_orders.tsv
done


# create LAYER ORDERS file
echo -e 'item_name\tdata_type\tdata_value' > $LAYER_ORDERS
# linearize order and append
for file in *intermediate.layer_orders.tsv
do
FILE_NAME=$(echo $file | awk -F'.' '{print $1}')
paste -sd"," $file | awk -v file_name="$FILE_NAME" 'BEGIN{FS=OFS="\t"}{print file_name,"basic",$0}' >> $LAYER_ORDERS
done


# transpose, linearize order and append
for file in *intermediate.layer_orders.tsv
do
FILE_NAME=$(echo $file | awk -F'.' '{print "Inverted_"$1}')
cat $file | tac | paste -sd","| awk -v file_name="$FILE_NAME" 'BEGIN{FS=OFS="\t"}{print file_name,"basic",$0}' >> $LAYER_ORDERS
done

# remove intermediate files
rm *intermediate.layer_orders.tsv

```


##### Build metpangenome.

```{bash, eval=FALSE}

projectID="P_0003_Neisseriaceae"

clusterize -n 10 -m jgiacomini@forsyth.org -log LOGS/metapangenome_summarise.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/script-06-metapangenome_summarize_pan_parallel.sh $projectID default

```

Need to repeat for PP and HP. 
```{bash}

#First remove HMP_PP and HMP_HP
rm -r 09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/HMP_PP 09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/HMP_HP

# Run again
clusterize -n 10 -m jgiacomini@forsyth.org -log LOGS/metapangenome_summarise_run_2.log /workspace/jmarkwelchlab/P_0003_Neisseriaceae/SCRIPTS/script-06-metapangenome_summarize_pan_parallel.sh $projectID default

```

##### Environmental core & accessory data.

```{bash ECG and EAG}

projectID="P_0003_Neisseriaceae"
mainDIR="/workspace/jmarkwelchlab"
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome
genomeDB=$DIR_Pangenome/${projectID}-GENOMES.db
panDB=$DIR_Pangenome/${projectID}-RESULTS/${projectID}-PAN.db
panLayersOrder=$DIR_Pangenome/${projectID}-layer_orders.txt

# combining metapangenome
# get environmental core/accessory data
for site in BM TD PP PT PB TH KG SA HP 
do
siteDir=$DIR_Pangenome/HMP_${site}
panDB=$siteDir/${projectID}-RESULTS/${projectID}-PAN.db
itemsTable=$siteDir/${projectID}-${site}-items.txt
anvi-export-misc-data -p $panDB -t items -o $itemsTable
cat $itemsTable | awk -F'\t' -v OFS="\t" 'NR==1 {for (i=1; i<=NF; i++) {f[$i] = i}} { print $(f["ECGs_and_EAGs!EAG"]),$(f["ECGs_and_EAGs!ECG"]),$(f["ECGs_and_EAGs!NA"]),$(f["EAG_ECG_ratio"])}' | awk -v SITE="${site}_" -v OFS="\t" 'NR==1{print SITE$1,SITE$2,SITE$3,SITE$4}NR>1{print $1,$2,$3,$4}' > ${itemsTable}.intermediate
done


######## CHECK ############################################################
for site in BM TD PP PT PB TH KG SA HP 
do
    check_metapan(){
    cat 09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/HMP_${site}/P_0003_Neisseriaceae-${site}-items.txt.intermediate | grep -q "ECGs_and_EAGs"
    }
    if ! check_metapan; then
        echo "${site} ***Incomplete***"
    else
        echo "${site} Completed"
    fi
done

```

BM Completed
TD Completed
PP Completed
PT Completed
PB Completed
TH Completed
KG Completed
SA Completed
HP Completed


```{bash, eval=FALSE}

projectID="P_0003_Neisseriaceae"
mainDIR="/workspace/jmarkwelchlab"
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome
panDB=$DIR_Pangenome/${projectID}-RESULTS/${projectID}-PAN.db
environmentalGenes=$DIR_Pangenome/environmental_genes.tsv

cat $DIR_Pangenome/HMP_BM/${projectID}-BM-items.txt | cut -f1 > $environmentalGenes.intermediate
paste $environmentalGenes.intermediate $DIR_Pangenome/HMP_*/${projectID}-*-items.txt.intermediate > $environmentalGenes
rm $environmentalGenes.intermediate

# import to pangenomeDB
anvi-import-misc-data -p $panDB -t items $environmentalGenes

```


Visualize metapangenome

```{bash, eval=FALSE}
projectID="P_0003_Neisseriaceae"
mainDIR="/workspace/jmarkwelchlab"
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome
panDB=$DIR_Pangenome/${projectID}-RESULTS/${projectID}-PAN.db
genomesDB=$DIR_Pangenome/${projectID}-GENOMES.db

anvi-display-pan -p $panDB -g $genomesDB

```

##### Functional enrichment and EAG/ECG data


The primary objective of this analysis is to integrate metagenomic data with pangenomic analyses to elucidate the distribution and prevalence of gene clusters within environmental populations. This endeavor aims to differentiate between gene clusters that are ubiquitously present across these populations (ECGs) and those observed more sporadically (EAGs). The methodology hinges on two pivotal criteria:

Presence of Genome in Metagenomes: First, it's essential to establish the presence of the genome within the metagenomes, determining whether the metagenomic datasets are suitable for analyzing the genome and its associated gene clusters. This is evaluated using a --min-detection parameter, set by default to 0.5. This threshold mandates that at least half of a genome's nucleotides must be covered by at least one metagenome for it to be considered present in a given habitat. This criterion ensures the exclusion of genomes not adequately represented in the habitat due to insufficient sequencing depth or other biases, thereby focusing the analysis on gene clusters from genomes that are verifiably part of the environmental sample.

Classification of Gene Clusters as Core or Accessory: The second criterion involves classifying each gene cluster as 'core' (ECG) or 'accessory' (EAG) to the population sampled by the metagenome. This classification is based on the --fraction-of-median-coverage parameter set to 0.25, which compares each gene cluster's median coverage against the genome's median coverage within the same metagenomes. Gene clusters meeting or exceeding a median coverage of 0.25 times the genome's median coverage are categorized as environmental core, indicating their prevalent presence and potential essentiality to the population. Conversely, gene clusters below this threshold are considered environmental accessory, signifying their sporadic presence or non-essential nature.

This approach enables a comprehensive assessment of the genetic architecture of microbial communities within specific environments. By focusing on gene clusters, this study acknowledges the complexity of microbial genomes, where multiple genes contribute to particular functions or adaptations. Identifying environmental core and accessory gene clusters offers profound insights into the ecological and evolutionary dynamics shaping microbial populations, revealing which gene clusters are integral to community survival and function and which are less consistently present or potentially involved in niche-specific adaptations.


Send ECG/EAG results to local

```{bash, eval=FALSE}

scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome/environmental_genes.tsv /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/G_0213/environmental_genes.tsv

```



###### Gene Cluster Function Information Extraction

The process begins with the retrieval of gene cluster function information from a pangenome summary. Using Bash scripting, the anvi-script-add-default-collection and anvi-summarize commands from the anvi'o suite are employed to organize and summarize gene cluster data from specified databases. The summary files are then uncompressed and transferred to a local directory for further processing. An awk script extracts pertinent information (unique ID, gene cluster ID, and COG20 function) from the summary text file, focusing on gene clusters' unique identifiers and their associated COG20 functional annotations. This extraction results in a curated file that lists each gene cluster alongside its COG20 function.

```{bash}

projectID="P_0003_Neisseriaceae"
mainDIR="/workspace/jmarkwelchlab"
DIR_Pangenome=$mainDIR/$projectID/09_PANGENOME/P_0003_Neisseriaceae_G_0213-pangenome
panDB=$DIR_Pangenome/${projectID}-RESULTS/${projectID}-PAN.db
genomesDB=$DIR_Pangenome/${projectID}-GENOMES.db


  
anvi-script-add-default-collection -p $panDB \
                                   -C default \
                                   -b bins 

anvi-summarize -g $genomesDB -p $panDB -o $mainDIR/$projectID/10_PANGENOME_SUMMARY/G_0213 -C default

# unzip summary file
gunzip $mainDIR/$projectID/10_PANGENOME_SUMMARY/G_0213/${projectID}_gene_clusters_summary.txt.gz

#send to local 
scp -r jgiacomini@evol5.mbl.edu:/workspace/jmarkwelchlab/P_0003_Neisseriaceae/10_PANGENOME_SUMMARY /Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/

```


Get gene cluster and COG20 functions...

```{bash, eval=FALSE}

file=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_summary.txt

out_file=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_COG20_functions.tsv


echo -e "uniqueID\tgene_cluster_ID\tCOG20_Function" > $out_file
awk -F'\t' 'NR==1 {for (i=1; i<=NF; i++) {if ($i=="unique_id") c1=i; if ($i=="gene_cluster_id") c2=i; if ($i=="COG20_FUNCTION") c3=i;}; next} {print $c1"\t"$c2"\t"$c3}' $file >> $out_file


```


###### Merging ECG/EAG Results with Gene Cluster Identity Functional Enrichment Results

Subsequent analysis in R involves merging environmental core/accessory gene (ECG/EAG) results with gene cluster identity functional enrichment results. Data frames containing ECG/EAG results, gene cluster enrichment results, and gene cluster functions are loaded into the R environment. The ECG/EAG results are then merged with gene cluster enrichment results based on a shared key, facilitating an integrated view of gene clusters' environmental significance and functional enrichment.

The workflow further refines the analysis to focus on gene clusters significantly enriched in a preferred oral site (e.g., Tongue Dorsum, TD) and classified as environmentally core. This is achieved through filtering operations that select gene clusters based on their adjusted q-values and association with the TD site, ensuring that only statistically significant and environmentally relevant gene clusters are considered. Additional filtering criteria ensure that only gene clusters with evidence of being environmentally core are retained.

To address potential redundancies in gene cluster function information, a consolidation step is implemented. This step involves selecting distinct records of gene cluster IDs and their associated COG20 functions, ensuring that each gene cluster ID is associated with a unique COG20 function annotation. The resultant dataset represents a refined list of gene clusters, each linked to a specific functional annotation without redundancy.

The refined list of environmentally significant and functionally annotated gene clusters is then merged with the consolidated gene cluster function information. This final merge operation ensures that all rows from the original dataset are retained, adding functional annotations where available. The outcome is a comprehensive dataset that combines environmental significance, functional enrichment, and COG20 functional annotations for each gene cluster, facilitating in-depth analyses of gene clusters' roles and distributions across environmental populations.



```{r, eval=FALSE}

# load data
ECG_EAG_results <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/09_PANGENOME/G_0213/environmental_genes.tsv", header = TRUE, sep = "\t")
  
GC_enrichment_results <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/GC_IDENTITY_Pangenome_Enrichment.txt", header =TRUE, sep = "\t")

gene_cluster_functions <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_COG20_functions.tsv",
                                     header = TRUE, sep = "\t")


# merge GC_enrichment_results with ECG_EAG_results
merged_results <- merge(GC_enrichment_results, ECG_EAG_results, by.x = "IDENTITY", by.y = "items")

# save merged data
write.table(merged_results, "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/GC_IDENTITY_Pangenome_Enrichment_ECG_EAG_results.txt", quote = FALSE, row.names = FALSE, sep = "\t")


# Filter for significant enrichment in TD
TD_significant_enrichment_and_ECG <- merged_results %>%
  filter(adjusted_q_value < 0.05) %>% 
  #filter(grepl("TD", associated_groups)) %>% # Adjusted to include gene clusters associated with TD among others
  filter(associated_groups == "TD") %>% # Adjusted to include gene clusters associated with TD among others
  #filter(TD_EAG_ECG_ratio == 0) %>% 
  filter(TD_ECGs_and_EAGs.ECG > 0) %>% 
  dplyr::select(IDENTITY, enrichment_score, adjusted_q_value, associated_groups,
                p_TD, p_SUPP, p_NONE, p_KG,
                TD_ECGs_and_EAGs.EAG,
                TD_ECGs_and_EAGs.ECG,
                TD_ECGs_and_EAGs.NA,
                TD_EAG_ECG_ratio)


# consolidate redundant info
gene_cluster_functions_2 <- gene_cluster_functions %>% 
  dplyr:: select(gene_cluster_ID, COG20_Function) %>% distinct() %>% 
  filter(!is.na(COG20_Function) & COG20_Function != "") %>%
  distinct(gene_cluster_ID, .keep_all = TRUE)


# Merge TD_significant_enrichment_and_ECG with consolidated gene_cluster_functions info
TD_significant_enrichment_and_ECG_functions <- merge(TD_significant_enrichment_and_ECG,gene_cluster_functions_2, by.x = "IDENTITY", by.y = "gene_cluster_ID", all.x = TRUE)

# Save table

write.table(TD_significant_enrichment_and_ECG_functions, "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/TD_enriched_GCs_ECG_COG20_functions.tsv", quote = FALSE, row.names = FALSE, sep = "\t")

```


###### KG

```{r, eval=FALSE}

# load data
merged_results <- read.table( "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/GC_IDENTITY_Pangenome_Enrichment_ECG_EAG_results.txt", header = TRUE, sep = "\t")

gene_cluster_functions <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_COG20_functions.tsv",
                                     header = TRUE, sep = "\t")



# Filter for significant enrichment in TD
KG_significant_enrichment_and_ECG <- merged_results %>%
  filter(adjusted_q_value < 0.05) %>% 
  filter(associated_groups == "KG") %>% # Adjusted to include gene clusters associated with TD among others
  filter(KG_ECGs_and_EAGs.ECG > 0) %>% 
  dplyr::select(IDENTITY, enrichment_score, adjusted_q_value, associated_groups,
                p_TD, p_SUPP, p_NONE, p_KG,
                KG_ECGs_and_EAGs.EAG,
                KG_ECGs_and_EAGs.ECG,
                KG_ECGs_and_EAGs.NA,
                KG_EAG_ECG_ratio)


# consolidate redundant info
gene_cluster_functions_2 <- gene_cluster_functions %>% 
  dplyr:: select(gene_cluster_ID, COG20_Function) %>% distinct() %>% 
  filter(!is.na(COG20_Function) & COG20_Function != "") %>%
  distinct(gene_cluster_ID, .keep_all = TRUE)


# Merge TD_significant_enrichment_and_ECG with consolidated gene_cluster_functions info
KG_significant_enrichment_and_ECG_functions <- merge(KG_significant_enrichment_and_ECG,gene_cluster_functions_2, by.x = "IDENTITY", by.y = "gene_cluster_ID", all.x = TRUE)

# Save table

write.table(KG_significant_enrichment_and_ECG_functions, "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/KG_enriched_GCs_ECG_COG20_functions.tsv", quote = FALSE, row.names = FALSE, sep = "\t")

```

###### SUPP

```{r, eval=FALSE}

# load data
merged_results <- read.table( "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/GC_IDENTITY_Pangenome_Enrichment_ECG_EAG_results.txt", header = TRUE, sep = "\t")

gene_cluster_functions <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_COG20_functions.tsv",
                                     header = TRUE, sep = "\t")



# Filter for significant enrichment in TD
SUPP_significant_enrichment_and_ECG <- merged_results %>%
  filter(adjusted_q_value < 0.05) %>% 
  filter(associated_groups == "SUPP") %>% # Adjusted to include gene clusters associated with TD among others
  filter(PP_ECGs_and_EAGs.ECG > 0) %>% 
  dplyr::select(IDENTITY, enrichment_score, adjusted_q_value, associated_groups,
                p_TD, p_SUPP, p_NONE, p_KG,
                PP_ECGs_and_EAGs.EAG,
                PP_ECGs_and_EAGs.ECG,
                PP_ECGs_and_EAGs.NA,
                PP_EAG_ECG_ratio)


# consolidate redundant info
gene_cluster_functions_2 <- gene_cluster_functions %>% 
  dplyr:: select(gene_cluster_ID, COG20_Function) %>% distinct() %>% 
  filter(!is.na(COG20_Function) & COG20_Function != "") %>%
  distinct(gene_cluster_ID, .keep_all = TRUE)


# Merge TD_significant_enrichment_and_ECG with consolidated gene_cluster_functions info
SUPP_significant_enrichment_and_ECG_functions <- merge(SUPP_significant_enrichment_and_ECG,gene_cluster_functions_2, by.x = "IDENTITY", by.y = "gene_cluster_ID", all.x = TRUE)

# Save table

write.table(SUPP_significant_enrichment_and_ECG_functions, "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/SUPP_enriched_GCs_ECG_COG20_functions.tsv", quote = FALSE, row.names = FALSE, sep = "\t")

```



###### Detected_vs_Undetected (TD,SUPP,KG vs NONE)

```{r, eval=FALSE}

# load data
merged_results <- read.table( "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/GC_IDENTITY_Pangenome_Enrichment_ECG_EAG_results.txt", header = TRUE, sep = "\t")

gene_cluster_functions <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_COG20_functions.tsv",
                                     header = TRUE, sep = "\t")



# Filter for significant enrichment in TD
DETECTED_significant_enrichment_and_ECG <- merged_results %>%
  filter(adjusted_q_value < 0.05) %>% 
  filter(associated_groups == "KG, SUPP, TD") %>% # Adjusted to include gene clusters associated with TD among others
  filter(KG_ECGs_and_EAGs.ECG > 0 & PP_ECGs_and_EAGs.ECG > 0 & TD_ECGs_and_EAGs.ECG > 0) %>% 
  dplyr::select(IDENTITY, enrichment_score, adjusted_q_value, associated_groups,
                p_TD, p_SUPP, p_NONE, p_KG,
                KG_ECGs_and_EAGs.EAG,
                KG_ECGs_and_EAGs.ECG,
                KG_ECGs_and_EAGs.NA,
                KG_EAG_ECG_ratio,
                TD_ECGs_and_EAGs.EAG,
                TD_ECGs_and_EAGs.ECG,
                TD_ECGs_and_EAGs.NA,
                TD_EAG_ECG_ratio,
                PP_ECGs_and_EAGs.EAG,
                PP_ECGs_and_EAGs.ECG,
                PP_ECGs_and_EAGs.NA,
                PP_EAG_ECG_ratio)


# consolidate redundant info
gene_cluster_functions_2 <- gene_cluster_functions %>% 
  dplyr:: select(gene_cluster_ID, COG20_Function) %>% distinct() %>% 
  filter(!is.na(COG20_Function) & COG20_Function != "") %>%
  distinct(gene_cluster_ID, .keep_all = TRUE)


# Merge TD_significant_enrichment_and_ECG with consolidated gene_cluster_functions info
DETECTED_significant_enrichment_and_ECG_functions <- merge(DETECTED_significant_enrichment_and_ECG,gene_cluster_functions_2, by.x = "IDENTITY", by.y = "gene_cluster_ID", all.x = TRUE)

# Save table

write.table(DETECTED_significant_enrichment_and_ECG_functions, "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/DETECTED_enriched_GCs_ECG_COG20_functions.tsv", quote = FALSE, row.names = FALSE, sep = "\t")

```


###### COG20_Categories

```{bash, eval=FALSE}

file=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_summary.txt

out_file=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_COG20_CATEGORY.tsv


echo -e "uniqueID\tgene_cluster_ID\tCOG20_CATEGORY" > $out_file
awk -F'\t' 'NR==1 {for (i=1; i<=NF; i++) {if ($i=="unique_id") c1=i; if ($i=="gene_cluster_id") c2=i; if ($i=="COG20_CATEGORY") c3=i;}; next} {print $c1"\t"$c2"\t"$c3}' $file >> $out_file


```


```{r, eval=FALSE}

# load data

gene_cluster_functions <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_COG20_CATEGORY.tsv",
                                     header = TRUE, sep = "\t")

merged_results <- read.table( "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/GC_IDENTITY_Pangenome_Enrichment_ECG_EAG_results.txt", header = TRUE, sep = "\t")

# Filter for significant enrichment in TD
TD_significant_enrichment_and_ECG <- merged_results %>%
  filter(adjusted_q_value < 0.05) %>% 
  filter(associated_groups == "TD") %>% # Adjusted to include gene clusters associated with TD among others
  filter(TD_ECGs_and_EAGs.ECG > 0) %>% 
  dplyr::select(IDENTITY, enrichment_score, adjusted_q_value, associated_groups,
                p_TD, p_SUPP, p_NONE, p_KG,
                TD_ECGs_and_EAGs.EAG,
                TD_ECGs_and_EAGs.ECG,
                TD_ECGs_and_EAGs.NA,
                TD_EAG_ECG_ratio)


# consolidate redundant info
gene_cluster_functions_2 <- gene_cluster_functions %>% 
  dplyr:: select(gene_cluster_ID, COG20_CATEGORY) %>% distinct() %>% 
  filter(!is.na(COG20_CATEGORY) & COG20_CATEGORY != "") %>%
  distinct(gene_cluster_ID, .keep_all = TRUE)


# Merge TD_significant_enrichment_and_ECG with consolidated gene_cluster_functions info
TD_significant_enrichment_and_ECG_functions <- merge(TD_significant_enrichment_and_ECG,gene_cluster_functions_2, by.x = "IDENTITY", by.y = "gene_cluster_ID", all.x = TRUE)

# Save table
write.table(TD_significant_enrichment_and_ECG_functions, "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/TD_enriched_GCs_ECG_COG20_CATEGORY.tsv", quote = FALSE, row.names = FALSE, sep = "\t")

```

```{r, eval=FALSE}

library(dplyr)
library(ggplot2)
library(forcats)

data <- TD_significant_enrichment_and_ECG_functions

data$COG20_CATEGORY <- as.factor(data$COG20_CATEGORY)

data <- data %>%
  mutate(COG20_CATEGORY = fct_lump_n(COG20_CATEGORY, n = 20)) %>%
  mutate(COG20_CATEGORY = fct_infreq(COG20_CATEGORY))


ggplot(data, aes(x = COG20_CATEGORY)) +
  geom_bar(fill = "steelblue4", color = "black") +
  scale_y_continuous(limits = c(0,40)) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10, color = "black"), # Rotate x-axis labels for readability
        legend.position = "none") + # Omit the legend
  labs(title = "Distribution of top 20 most common COG20 Categories", 
       x = "COG20 Category", 
       y = "Frequency") 

ggsave("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/TD_enriched_GCs_ECG_COG20_CATEGORY_plot.pdf", width = 10, height = 10)

```


###### Pfams

```{bash, eval=FALSE}

file=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_summary.txt

out_file=/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_Pfams.tsv


echo -e "uniqueID\tgene_cluster_ID\tPfam" > $out_file
awk -F'\t' 'NR==1 {for (i=1; i<=NF; i++) {if ($i=="unique_id") c1=i; if ($i=="gene_cluster_id") c2=i; if ($i=="Pfam") c3=i;}; next} {print $c1"\t"$c2"\t"$c3}' $file >> $out_file


```


```{r, eval=FALSE}

# load data

gene_cluster_functions <- read.table("/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/10_PANGENOME_SUMMARY/G_0213/P_0003_Neisseriaceae_gene_clusters_Pfams.tsv",
                                     header = TRUE, sep = "\t")

merged_results <- read.table( "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/GC_IDENTITY_Pangenome_Enrichment_ECG_EAG_results.txt", header = TRUE, sep = "\t")

# Filter for significant enrichment in TD
TD_significant_enrichment_and_ECG <- merged_results %>%
  filter(adjusted_q_value < 0.05) %>% 
  filter(associated_groups == "TD") %>% # Adjusted to include gene clusters associated with TD among others
  filter(TD_ECGs_and_EAGs.ECG > 0) %>% 
  dplyr::select(IDENTITY, enrichment_score, adjusted_q_value, associated_groups,
                p_TD, p_SUPP, p_NONE, p_KG,
                TD_ECGs_and_EAGs.EAG,
                TD_ECGs_and_EAGs.ECG,
                TD_ECGs_and_EAGs.NA,
                TD_EAG_ECG_ratio)


# consolidate redundant info
gene_cluster_functions_2 <- gene_cluster_functions %>% 
  dplyr:: select(gene_cluster_ID, Pfam) %>% distinct() %>% 
  filter(!is.na(Pfam) & Pfam != "") %>%
  distinct(gene_cluster_ID, .keep_all = TRUE)


# Merge TD_significant_enrichment_and_ECG with consolidated gene_cluster_functions info
TD_significant_enrichment_and_ECG_functions <- merge(TD_significant_enrichment_and_ECG,gene_cluster_functions_2, by.x = "IDENTITY", by.y = "gene_cluster_ID", all.x = TRUE)

# Save table
write.table(TD_significant_enrichment_and_ECG_functions, "/Users/home/SPECIES_LEVEL_PANGENOMES/Neisseriaceae/20_FUNCTIONAL_ENRICHMENT/TD_enriched_GCs_ECG_Pfam.tsv", quote = FALSE, row.names = FALSE, sep = "\t")

```
